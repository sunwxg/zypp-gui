// Generated by gir (https://github.com/gtk-rs/gir @ f3d92ad)
// from /home/home/person/git_hub/gir-files (@ 7d95377)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]
#![allow(
    clippy::approx_constant,
    clippy::type_complexity,
    clippy::unreadable_literal,
    clippy::upper_case_acronyms
)]

use gio_sys as gio;
use glib_sys as glib;
use gobject_sys as gobject;

#[allow(unused_imports)]
use libc::{
    c_char, c_double, c_float, c_int, c_long, c_short, c_uchar, c_uint, c_ulong, c_ushort, c_void,
    intptr_t, size_t, ssize_t, time_t, uintptr_t, FILE,
};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType};

// Aliases
pub type PkBitfield = u64;

// Enums
pub type PkAuthorizeEnum = c_int;
pub const PK_AUTHORIZE_ENUM_UNKNOWN: PkAuthorizeEnum = 0;
pub const PK_AUTHORIZE_ENUM_YES: PkAuthorizeEnum = 1;
pub const PK_AUTHORIZE_ENUM_NO: PkAuthorizeEnum = 2;
pub const PK_AUTHORIZE_ENUM_INTERACTIVE: PkAuthorizeEnum = 3;
pub const PK_AUTHORIZE_ENUM_LAST: PkAuthorizeEnum = 4;

pub type PkClientError = c_int;
pub const PK_CLIENT_ERROR_FAILED: PkClientError = 0;
pub const PK_CLIENT_ERROR_FAILED_AUTH: PkClientError = 1;
pub const PK_CLIENT_ERROR_NO_TID: PkClientError = 2;
pub const PK_CLIENT_ERROR_ALREADY_TID: PkClientError = 3;
pub const PK_CLIENT_ERROR_ROLE_UNKNOWN: PkClientError = 4;
pub const PK_CLIENT_ERROR_CANNOT_START_DAEMON: PkClientError = 5;
pub const PK_CLIENT_ERROR_INVALID_INPUT: PkClientError = 6;
pub const PK_CLIENT_ERROR_INVALID_FILE: PkClientError = 7;
pub const PK_CLIENT_ERROR_NOT_SUPPORTED: PkClientError = 8;
pub const PK_CLIENT_ERROR_DECLINED_SIMULATION: PkClientError = 9;
pub const PK_CLIENT_ERROR_LAST: PkClientError = 10;

pub type PkControlError = c_int;
pub const PK_CONTROL_ERROR_FAILED: PkControlError = 0;
pub const PK_CONTROL_ERROR_CANNOT_START_DAEMON: PkControlError = 1;

pub type PkDistroUpgradeEnum = c_int;
pub const PK_DISTRO_UPGRADE_ENUM_UNKNOWN: PkDistroUpgradeEnum = 0;
pub const PK_DISTRO_UPGRADE_ENUM_STABLE: PkDistroUpgradeEnum = 1;
pub const PK_DISTRO_UPGRADE_ENUM_UNSTABLE: PkDistroUpgradeEnum = 2;
pub const PK_DISTRO_UPGRADE_ENUM_LAST: PkDistroUpgradeEnum = 3;

pub type PkErrorEnum = c_int;
pub const PK_ERROR_ENUM_UNKNOWN: PkErrorEnum = 0;
pub const PK_ERROR_ENUM_OOM: PkErrorEnum = 1;
pub const PK_ERROR_ENUM_NO_NETWORK: PkErrorEnum = 2;
pub const PK_ERROR_ENUM_NOT_SUPPORTED: PkErrorEnum = 3;
pub const PK_ERROR_ENUM_INTERNAL_ERROR: PkErrorEnum = 4;
pub const PK_ERROR_ENUM_GPG_FAILURE: PkErrorEnum = 5;
pub const PK_ERROR_ENUM_PACKAGE_ID_INVALID: PkErrorEnum = 6;
pub const PK_ERROR_ENUM_PACKAGE_NOT_INSTALLED: PkErrorEnum = 7;
pub const PK_ERROR_ENUM_PACKAGE_NOT_FOUND: PkErrorEnum = 8;
pub const PK_ERROR_ENUM_PACKAGE_ALREADY_INSTALLED: PkErrorEnum = 9;
pub const PK_ERROR_ENUM_PACKAGE_DOWNLOAD_FAILED: PkErrorEnum = 10;
pub const PK_ERROR_ENUM_GROUP_NOT_FOUND: PkErrorEnum = 11;
pub const PK_ERROR_ENUM_GROUP_LIST_INVALID: PkErrorEnum = 12;
pub const PK_ERROR_ENUM_DEP_RESOLUTION_FAILED: PkErrorEnum = 13;
pub const PK_ERROR_ENUM_FILTER_INVALID: PkErrorEnum = 14;
pub const PK_ERROR_ENUM_CREATE_THREAD_FAILED: PkErrorEnum = 15;
pub const PK_ERROR_ENUM_TRANSACTION_ERROR: PkErrorEnum = 16;
pub const PK_ERROR_ENUM_TRANSACTION_CANCELLED: PkErrorEnum = 17;
pub const PK_ERROR_ENUM_NO_CACHE: PkErrorEnum = 18;
pub const PK_ERROR_ENUM_REPO_NOT_FOUND: PkErrorEnum = 19;
pub const PK_ERROR_ENUM_CANNOT_REMOVE_SYSTEM_PACKAGE: PkErrorEnum = 20;
pub const PK_ERROR_ENUM_PROCESS_KILL: PkErrorEnum = 21;
pub const PK_ERROR_ENUM_FAILED_INITIALIZATION: PkErrorEnum = 22;
pub const PK_ERROR_ENUM_FAILED_FINALISE: PkErrorEnum = 23;
pub const PK_ERROR_ENUM_FAILED_CONFIG_PARSING: PkErrorEnum = 24;
pub const PK_ERROR_ENUM_CANNOT_CANCEL: PkErrorEnum = 25;
pub const PK_ERROR_ENUM_CANNOT_GET_LOCK: PkErrorEnum = 26;
pub const PK_ERROR_ENUM_NO_PACKAGES_TO_UPDATE: PkErrorEnum = 27;
pub const PK_ERROR_ENUM_CANNOT_WRITE_REPO_CONFIG: PkErrorEnum = 28;
pub const PK_ERROR_ENUM_LOCAL_INSTALL_FAILED: PkErrorEnum = 29;
pub const PK_ERROR_ENUM_BAD_GPG_SIGNATURE: PkErrorEnum = 30;
pub const PK_ERROR_ENUM_MISSING_GPG_SIGNATURE: PkErrorEnum = 31;
pub const PK_ERROR_ENUM_CANNOT_INSTALL_SOURCE_PACKAGE: PkErrorEnum = 32;
pub const PK_ERROR_ENUM_REPO_CONFIGURATION_ERROR: PkErrorEnum = 33;
pub const PK_ERROR_ENUM_NO_LICENSE_AGREEMENT: PkErrorEnum = 34;
pub const PK_ERROR_ENUM_FILE_CONFLICTS: PkErrorEnum = 35;
pub const PK_ERROR_ENUM_PACKAGE_CONFLICTS: PkErrorEnum = 36;
pub const PK_ERROR_ENUM_REPO_NOT_AVAILABLE: PkErrorEnum = 37;
pub const PK_ERROR_ENUM_INVALID_PACKAGE_FILE: PkErrorEnum = 38;
pub const PK_ERROR_ENUM_PACKAGE_INSTALL_BLOCKED: PkErrorEnum = 39;
pub const PK_ERROR_ENUM_PACKAGE_CORRUPT: PkErrorEnum = 40;
pub const PK_ERROR_ENUM_ALL_PACKAGES_ALREADY_INSTALLED: PkErrorEnum = 41;
pub const PK_ERROR_ENUM_FILE_NOT_FOUND: PkErrorEnum = 42;
pub const PK_ERROR_ENUM_NO_MORE_MIRRORS_TO_TRY: PkErrorEnum = 43;
pub const PK_ERROR_ENUM_NO_DISTRO_UPGRADE_DATA: PkErrorEnum = 44;
pub const PK_ERROR_ENUM_INCOMPATIBLE_ARCHITECTURE: PkErrorEnum = 45;
pub const PK_ERROR_ENUM_NO_SPACE_ON_DEVICE: PkErrorEnum = 46;
pub const PK_ERROR_ENUM_MEDIA_CHANGE_REQUIRED: PkErrorEnum = 47;
pub const PK_ERROR_ENUM_NOT_AUTHORIZED: PkErrorEnum = 48;
pub const PK_ERROR_ENUM_UPDATE_NOT_FOUND: PkErrorEnum = 49;
pub const PK_ERROR_ENUM_CANNOT_INSTALL_REPO_UNSIGNED: PkErrorEnum = 50;
pub const PK_ERROR_ENUM_CANNOT_UPDATE_REPO_UNSIGNED: PkErrorEnum = 51;
pub const PK_ERROR_ENUM_CANNOT_GET_FILELIST: PkErrorEnum = 52;
pub const PK_ERROR_ENUM_CANNOT_GET_REQUIRES: PkErrorEnum = 53;
pub const PK_ERROR_ENUM_CANNOT_DISABLE_REPOSITORY: PkErrorEnum = 54;
pub const PK_ERROR_ENUM_RESTRICTED_DOWNLOAD: PkErrorEnum = 55;
pub const PK_ERROR_ENUM_PACKAGE_FAILED_TO_CONFIGURE: PkErrorEnum = 56;
pub const PK_ERROR_ENUM_PACKAGE_FAILED_TO_BUILD: PkErrorEnum = 57;
pub const PK_ERROR_ENUM_PACKAGE_FAILED_TO_INSTALL: PkErrorEnum = 58;
pub const PK_ERROR_ENUM_PACKAGE_FAILED_TO_REMOVE: PkErrorEnum = 59;
pub const PK_ERROR_ENUM_UPDATE_FAILED_DUE_TO_RUNNING_PROCESS: PkErrorEnum = 60;
pub const PK_ERROR_ENUM_PACKAGE_DATABASE_CHANGED: PkErrorEnum = 61;
pub const PK_ERROR_ENUM_PROVIDE_TYPE_NOT_SUPPORTED: PkErrorEnum = 62;
pub const PK_ERROR_ENUM_INSTALL_ROOT_INVALID: PkErrorEnum = 63;
pub const PK_ERROR_ENUM_CANNOT_FETCH_SOURCES: PkErrorEnum = 64;
pub const PK_ERROR_ENUM_CANCELLED_PRIORITY: PkErrorEnum = 65;
pub const PK_ERROR_ENUM_UNFINISHED_TRANSACTION: PkErrorEnum = 66;
pub const PK_ERROR_ENUM_LOCK_REQUIRED: PkErrorEnum = 67;
pub const PK_ERROR_ENUM_REPO_ALREADY_SET: PkErrorEnum = 68;
pub const PK_ERROR_ENUM_LAST: PkErrorEnum = 69;

pub type PkExitEnum = c_int;
pub const PK_EXIT_ENUM_UNKNOWN: PkExitEnum = 0;
pub const PK_EXIT_ENUM_SUCCESS: PkExitEnum = 1;
pub const PK_EXIT_ENUM_FAILED: PkExitEnum = 2;
pub const PK_EXIT_ENUM_CANCELLED: PkExitEnum = 3;
pub const PK_EXIT_ENUM_KEY_REQUIRED: PkExitEnum = 4;
pub const PK_EXIT_ENUM_EULA_REQUIRED: PkExitEnum = 5;
pub const PK_EXIT_ENUM_KILLED: PkExitEnum = 6;
pub const PK_EXIT_ENUM_MEDIA_CHANGE_REQUIRED: PkExitEnum = 7;
pub const PK_EXIT_ENUM_NEED_UNTRUSTED: PkExitEnum = 8;
pub const PK_EXIT_ENUM_CANCELLED_PRIORITY: PkExitEnum = 9;
pub const PK_EXIT_ENUM_SKIP_TRANSACTION: PkExitEnum = 10;
pub const PK_EXIT_ENUM_REPAIR_REQUIRED: PkExitEnum = 11;
pub const PK_EXIT_ENUM_LAST: PkExitEnum = 12;

pub type PkFilterEnum = c_int;
pub const PK_FILTER_ENUM_UNKNOWN: PkFilterEnum = 0;
pub const PK_FILTER_ENUM_NONE: PkFilterEnum = 1;
pub const PK_FILTER_ENUM_INSTALLED: PkFilterEnum = 2;
pub const PK_FILTER_ENUM_NOT_INSTALLED: PkFilterEnum = 3;
pub const PK_FILTER_ENUM_DEVELOPMENT: PkFilterEnum = 4;
pub const PK_FILTER_ENUM_NOT_DEVELOPMENT: PkFilterEnum = 5;
pub const PK_FILTER_ENUM_GUI: PkFilterEnum = 6;
pub const PK_FILTER_ENUM_NOT_GUI: PkFilterEnum = 7;
pub const PK_FILTER_ENUM_FREE: PkFilterEnum = 8;
pub const PK_FILTER_ENUM_NOT_FREE: PkFilterEnum = 9;
pub const PK_FILTER_ENUM_VISIBLE: PkFilterEnum = 10;
pub const PK_FILTER_ENUM_NOT_VISIBLE: PkFilterEnum = 11;
pub const PK_FILTER_ENUM_SUPPORTED: PkFilterEnum = 12;
pub const PK_FILTER_ENUM_NOT_SUPPORTED: PkFilterEnum = 13;
pub const PK_FILTER_ENUM_BASENAME: PkFilterEnum = 14;
pub const PK_FILTER_ENUM_NOT_BASENAME: PkFilterEnum = 15;
pub const PK_FILTER_ENUM_NEWEST: PkFilterEnum = 16;
pub const PK_FILTER_ENUM_NOT_NEWEST: PkFilterEnum = 17;
pub const PK_FILTER_ENUM_ARCH: PkFilterEnum = 18;
pub const PK_FILTER_ENUM_NOT_ARCH: PkFilterEnum = 19;
pub const PK_FILTER_ENUM_SOURCE: PkFilterEnum = 20;
pub const PK_FILTER_ENUM_NOT_SOURCE: PkFilterEnum = 21;
pub const PK_FILTER_ENUM_COLLECTIONS: PkFilterEnum = 22;
pub const PK_FILTER_ENUM_NOT_COLLECTIONS: PkFilterEnum = 23;
pub const PK_FILTER_ENUM_APPLICATION: PkFilterEnum = 24;
pub const PK_FILTER_ENUM_NOT_APPLICATION: PkFilterEnum = 25;
pub const PK_FILTER_ENUM_DOWNLOADED: PkFilterEnum = 26;
pub const PK_FILTER_ENUM_NOT_DOWNLOADED: PkFilterEnum = 27;
pub const PK_FILTER_ENUM_LAST: PkFilterEnum = 28;

pub type PkGroupEnum = c_int;
pub const PK_GROUP_ENUM_UNKNOWN: PkGroupEnum = 0;
pub const PK_GROUP_ENUM_ACCESSIBILITY: PkGroupEnum = 1;
pub const PK_GROUP_ENUM_ACCESSORIES: PkGroupEnum = 2;
pub const PK_GROUP_ENUM_ADMIN_TOOLS: PkGroupEnum = 3;
pub const PK_GROUP_ENUM_COMMUNICATION: PkGroupEnum = 4;
pub const PK_GROUP_ENUM_DESKTOP_GNOME: PkGroupEnum = 5;
pub const PK_GROUP_ENUM_DESKTOP_KDE: PkGroupEnum = 6;
pub const PK_GROUP_ENUM_DESKTOP_OTHER: PkGroupEnum = 7;
pub const PK_GROUP_ENUM_DESKTOP_XFCE: PkGroupEnum = 8;
pub const PK_GROUP_ENUM_EDUCATION: PkGroupEnum = 9;
pub const PK_GROUP_ENUM_FONTS: PkGroupEnum = 10;
pub const PK_GROUP_ENUM_GAMES: PkGroupEnum = 11;
pub const PK_GROUP_ENUM_GRAPHICS: PkGroupEnum = 12;
pub const PK_GROUP_ENUM_INTERNET: PkGroupEnum = 13;
pub const PK_GROUP_ENUM_LEGACY: PkGroupEnum = 14;
pub const PK_GROUP_ENUM_LOCALIZATION: PkGroupEnum = 15;
pub const PK_GROUP_ENUM_MAPS: PkGroupEnum = 16;
pub const PK_GROUP_ENUM_MULTIMEDIA: PkGroupEnum = 17;
pub const PK_GROUP_ENUM_NETWORK: PkGroupEnum = 18;
pub const PK_GROUP_ENUM_OFFICE: PkGroupEnum = 19;
pub const PK_GROUP_ENUM_OTHER: PkGroupEnum = 20;
pub const PK_GROUP_ENUM_POWER_MANAGEMENT: PkGroupEnum = 21;
pub const PK_GROUP_ENUM_PROGRAMMING: PkGroupEnum = 22;
pub const PK_GROUP_ENUM_PUBLISHING: PkGroupEnum = 23;
pub const PK_GROUP_ENUM_REPOS: PkGroupEnum = 24;
pub const PK_GROUP_ENUM_SECURITY: PkGroupEnum = 25;
pub const PK_GROUP_ENUM_SERVERS: PkGroupEnum = 26;
pub const PK_GROUP_ENUM_SYSTEM: PkGroupEnum = 27;
pub const PK_GROUP_ENUM_VIRTUALIZATION: PkGroupEnum = 28;
pub const PK_GROUP_ENUM_SCIENCE: PkGroupEnum = 29;
pub const PK_GROUP_ENUM_DOCUMENTATION: PkGroupEnum = 30;
pub const PK_GROUP_ENUM_ELECTRONICS: PkGroupEnum = 31;
pub const PK_GROUP_ENUM_COLLECTIONS: PkGroupEnum = 32;
pub const PK_GROUP_ENUM_VENDOR: PkGroupEnum = 33;
pub const PK_GROUP_ENUM_NEWEST: PkGroupEnum = 34;
pub const PK_GROUP_ENUM_LAST: PkGroupEnum = 35;

pub type PkInfoEnum = c_int;
pub const PK_INFO_ENUM_UNKNOWN: PkInfoEnum = 0;
pub const PK_INFO_ENUM_INSTALLED: PkInfoEnum = 1;
pub const PK_INFO_ENUM_AVAILABLE: PkInfoEnum = 2;
pub const PK_INFO_ENUM_LOW: PkInfoEnum = 3;
pub const PK_INFO_ENUM_ENHANCEMENT: PkInfoEnum = 4;
pub const PK_INFO_ENUM_NORMAL: PkInfoEnum = 5;
pub const PK_INFO_ENUM_BUGFIX: PkInfoEnum = 6;
pub const PK_INFO_ENUM_IMPORTANT: PkInfoEnum = 7;
pub const PK_INFO_ENUM_SECURITY: PkInfoEnum = 8;
pub const PK_INFO_ENUM_BLOCKED: PkInfoEnum = 9;
pub const PK_INFO_ENUM_DOWNLOADING: PkInfoEnum = 10;
pub const PK_INFO_ENUM_UPDATING: PkInfoEnum = 11;
pub const PK_INFO_ENUM_INSTALLING: PkInfoEnum = 12;
pub const PK_INFO_ENUM_REMOVING: PkInfoEnum = 13;
pub const PK_INFO_ENUM_CLEANUP: PkInfoEnum = 14;
pub const PK_INFO_ENUM_OBSOLETING: PkInfoEnum = 15;
pub const PK_INFO_ENUM_COLLECTION_INSTALLED: PkInfoEnum = 16;
pub const PK_INFO_ENUM_COLLECTION_AVAILABLE: PkInfoEnum = 17;
pub const PK_INFO_ENUM_FINISHED: PkInfoEnum = 18;
pub const PK_INFO_ENUM_REINSTALLING: PkInfoEnum = 19;
pub const PK_INFO_ENUM_DOWNGRADING: PkInfoEnum = 20;
pub const PK_INFO_ENUM_PREPARING: PkInfoEnum = 21;
pub const PK_INFO_ENUM_DECOMPRESSING: PkInfoEnum = 22;
pub const PK_INFO_ENUM_UNTRUSTED: PkInfoEnum = 23;
pub const PK_INFO_ENUM_TRUSTED: PkInfoEnum = 24;
pub const PK_INFO_ENUM_UNAVAILABLE: PkInfoEnum = 25;
pub const PK_INFO_ENUM_LAST: PkInfoEnum = 26;

pub type PkMediaTypeEnum = c_int;
pub const PK_MEDIA_TYPE_ENUM_UNKNOWN: PkMediaTypeEnum = 0;
pub const PK_MEDIA_TYPE_ENUM_CD: PkMediaTypeEnum = 1;
pub const PK_MEDIA_TYPE_ENUM_DVD: PkMediaTypeEnum = 2;
pub const PK_MEDIA_TYPE_ENUM_DISC: PkMediaTypeEnum = 3;
pub const PK_MEDIA_TYPE_ENUM_LAST: PkMediaTypeEnum = 4;

pub type PkNetworkEnum = c_int;
pub const PK_NETWORK_ENUM_UNKNOWN: PkNetworkEnum = 0;
pub const PK_NETWORK_ENUM_OFFLINE: PkNetworkEnum = 1;
pub const PK_NETWORK_ENUM_ONLINE: PkNetworkEnum = 2;
pub const PK_NETWORK_ENUM_WIRED: PkNetworkEnum = 3;
pub const PK_NETWORK_ENUM_WIFI: PkNetworkEnum = 4;
pub const PK_NETWORK_ENUM_MOBILE: PkNetworkEnum = 5;
pub const PK_NETWORK_ENUM_LAST: PkNetworkEnum = 6;

pub type PkOfflineAction = c_int;
pub const PK_OFFLINE_ACTION_UNKNOWN: PkOfflineAction = 0;
pub const PK_OFFLINE_ACTION_REBOOT: PkOfflineAction = 1;
pub const PK_OFFLINE_ACTION_POWER_OFF: PkOfflineAction = 2;
pub const PK_OFFLINE_ACTION_UNSET: PkOfflineAction = 3;
pub const PK_OFFLINE_ACTION_LAST: PkOfflineAction = 4;

pub type PkOfflineError = c_int;
pub const PK_OFFLINE_ERROR_FAILED: PkOfflineError = 0;
pub const PK_OFFLINE_ERROR_INVALID_VALUE: PkOfflineError = 1;
pub const PK_OFFLINE_ERROR_NO_DATA: PkOfflineError = 2;
pub const PK_OFFLINE_ERROR_LAST: PkOfflineError = 3;

pub type PkPackageSackSortType = c_int;
pub const PK_PACKAGE_SACK_SORT_TYPE_NAME: PkPackageSackSortType = 0;
pub const PK_PACKAGE_SACK_SORT_TYPE_INFO: PkPackageSackSortType = 1;
pub const PK_PACKAGE_SACK_SORT_TYPE_PACKAGE_ID: PkPackageSackSortType = 2;
pub const PK_PACKAGE_SACK_SORT_TYPE_SUMMARY: PkPackageSackSortType = 3;
pub const PK_PACKAGE_SACK_SORT_TYPE_LAST: PkPackageSackSortType = 4;

pub type PkProgressType = c_int;
pub const PK_PROGRESS_TYPE_PACKAGE_ID: PkProgressType = 0;
pub const PK_PROGRESS_TYPE_TRANSACTION_ID: PkProgressType = 1;
pub const PK_PROGRESS_TYPE_PERCENTAGE: PkProgressType = 2;
pub const PK_PROGRESS_TYPE_ALLOW_CANCEL: PkProgressType = 3;
pub const PK_PROGRESS_TYPE_STATUS: PkProgressType = 4;
pub const PK_PROGRESS_TYPE_ROLE: PkProgressType = 5;
pub const PK_PROGRESS_TYPE_CALLER_ACTIVE: PkProgressType = 6;
pub const PK_PROGRESS_TYPE_ELAPSED_TIME: PkProgressType = 7;
pub const PK_PROGRESS_TYPE_REMAINING_TIME: PkProgressType = 8;
pub const PK_PROGRESS_TYPE_SPEED: PkProgressType = 9;
pub const PK_PROGRESS_TYPE_DOWNLOAD_SIZE_REMAINING: PkProgressType = 10;
pub const PK_PROGRESS_TYPE_UID: PkProgressType = 11;
pub const PK_PROGRESS_TYPE_PACKAGE: PkProgressType = 12;
pub const PK_PROGRESS_TYPE_ITEM_PROGRESS: PkProgressType = 13;
pub const PK_PROGRESS_TYPE_TRANSACTION_FLAGS: PkProgressType = 14;
pub const PK_PROGRESS_TYPE_INVALID: PkProgressType = 15;

pub type PkRestartEnum = c_int;
pub const PK_RESTART_ENUM_UNKNOWN: PkRestartEnum = 0;
pub const PK_RESTART_ENUM_NONE: PkRestartEnum = 1;
pub const PK_RESTART_ENUM_APPLICATION: PkRestartEnum = 2;
pub const PK_RESTART_ENUM_SESSION: PkRestartEnum = 3;
pub const PK_RESTART_ENUM_SYSTEM: PkRestartEnum = 4;
pub const PK_RESTART_ENUM_SECURITY_SESSION: PkRestartEnum = 5;
pub const PK_RESTART_ENUM_SECURITY_SYSTEM: PkRestartEnum = 6;
pub const PK_RESTART_ENUM_LAST: PkRestartEnum = 7;

pub type PkRoleEnum = c_int;
pub const PK_ROLE_ENUM_UNKNOWN: PkRoleEnum = 0;
pub const PK_ROLE_ENUM_CANCEL: PkRoleEnum = 1;
pub const PK_ROLE_ENUM_DEPENDS_ON: PkRoleEnum = 2;
pub const PK_ROLE_ENUM_GET_DETAILS: PkRoleEnum = 3;
pub const PK_ROLE_ENUM_GET_FILES: PkRoleEnum = 4;
pub const PK_ROLE_ENUM_GET_PACKAGES: PkRoleEnum = 5;
pub const PK_ROLE_ENUM_GET_REPO_LIST: PkRoleEnum = 6;
pub const PK_ROLE_ENUM_REQUIRED_BY: PkRoleEnum = 7;
pub const PK_ROLE_ENUM_GET_UPDATE_DETAIL: PkRoleEnum = 8;
pub const PK_ROLE_ENUM_GET_UPDATES: PkRoleEnum = 9;
pub const PK_ROLE_ENUM_INSTALL_FILES: PkRoleEnum = 10;
pub const PK_ROLE_ENUM_INSTALL_PACKAGES: PkRoleEnum = 11;
pub const PK_ROLE_ENUM_INSTALL_SIGNATURE: PkRoleEnum = 12;
pub const PK_ROLE_ENUM_REFRESH_CACHE: PkRoleEnum = 13;
pub const PK_ROLE_ENUM_REMOVE_PACKAGES: PkRoleEnum = 14;
pub const PK_ROLE_ENUM_REPO_ENABLE: PkRoleEnum = 15;
pub const PK_ROLE_ENUM_REPO_SET_DATA: PkRoleEnum = 16;
pub const PK_ROLE_ENUM_RESOLVE: PkRoleEnum = 17;
pub const PK_ROLE_ENUM_SEARCH_DETAILS: PkRoleEnum = 18;
pub const PK_ROLE_ENUM_SEARCH_FILE: PkRoleEnum = 19;
pub const PK_ROLE_ENUM_SEARCH_GROUP: PkRoleEnum = 20;
pub const PK_ROLE_ENUM_SEARCH_NAME: PkRoleEnum = 21;
pub const PK_ROLE_ENUM_UPDATE_PACKAGES: PkRoleEnum = 22;
pub const PK_ROLE_ENUM_WHAT_PROVIDES: PkRoleEnum = 23;
pub const PK_ROLE_ENUM_ACCEPT_EULA: PkRoleEnum = 24;
pub const PK_ROLE_ENUM_DOWNLOAD_PACKAGES: PkRoleEnum = 25;
pub const PK_ROLE_ENUM_GET_DISTRO_UPGRADES: PkRoleEnum = 26;
pub const PK_ROLE_ENUM_GET_CATEGORIES: PkRoleEnum = 27;
pub const PK_ROLE_ENUM_GET_OLD_TRANSACTIONS: PkRoleEnum = 28;
pub const PK_ROLE_ENUM_REPAIR_SYSTEM: PkRoleEnum = 29;
pub const PK_ROLE_ENUM_GET_DETAILS_LOCAL: PkRoleEnum = 30;
pub const PK_ROLE_ENUM_GET_FILES_LOCAL: PkRoleEnum = 31;
pub const PK_ROLE_ENUM_REPO_REMOVE: PkRoleEnum = 32;
pub const PK_ROLE_ENUM_UPGRADE_SYSTEM: PkRoleEnum = 33;
pub const PK_ROLE_ENUM_LAST: PkRoleEnum = 34;

pub type PkSigTypeEnum = c_int;
pub const PK_SIGTYPE_ENUM_UNKNOWN: PkSigTypeEnum = 0;
pub const PK_SIGTYPE_ENUM_GPG: PkSigTypeEnum = 1;
pub const PK_SIGTYPE_ENUM_LAST: PkSigTypeEnum = 2;

pub type PkStatusEnum = c_int;
pub const PK_STATUS_ENUM_UNKNOWN: PkStatusEnum = 0;
pub const PK_STATUS_ENUM_WAIT: PkStatusEnum = 1;
pub const PK_STATUS_ENUM_SETUP: PkStatusEnum = 2;
pub const PK_STATUS_ENUM_RUNNING: PkStatusEnum = 3;
pub const PK_STATUS_ENUM_QUERY: PkStatusEnum = 4;
pub const PK_STATUS_ENUM_INFO: PkStatusEnum = 5;
pub const PK_STATUS_ENUM_REMOVE: PkStatusEnum = 6;
pub const PK_STATUS_ENUM_REFRESH_CACHE: PkStatusEnum = 7;
pub const PK_STATUS_ENUM_DOWNLOAD: PkStatusEnum = 8;
pub const PK_STATUS_ENUM_INSTALL: PkStatusEnum = 9;
pub const PK_STATUS_ENUM_UPDATE: PkStatusEnum = 10;
pub const PK_STATUS_ENUM_CLEANUP: PkStatusEnum = 11;
pub const PK_STATUS_ENUM_OBSOLETE: PkStatusEnum = 12;
pub const PK_STATUS_ENUM_DEP_RESOLVE: PkStatusEnum = 13;
pub const PK_STATUS_ENUM_SIG_CHECK: PkStatusEnum = 14;
pub const PK_STATUS_ENUM_TEST_COMMIT: PkStatusEnum = 15;
pub const PK_STATUS_ENUM_COMMIT: PkStatusEnum = 16;
pub const PK_STATUS_ENUM_REQUEST: PkStatusEnum = 17;
pub const PK_STATUS_ENUM_FINISHED: PkStatusEnum = 18;
pub const PK_STATUS_ENUM_CANCEL: PkStatusEnum = 19;
pub const PK_STATUS_ENUM_DOWNLOAD_REPOSITORY: PkStatusEnum = 20;
pub const PK_STATUS_ENUM_DOWNLOAD_PACKAGELIST: PkStatusEnum = 21;
pub const PK_STATUS_ENUM_DOWNLOAD_FILELIST: PkStatusEnum = 22;
pub const PK_STATUS_ENUM_DOWNLOAD_CHANGELOG: PkStatusEnum = 23;
pub const PK_STATUS_ENUM_DOWNLOAD_GROUP: PkStatusEnum = 24;
pub const PK_STATUS_ENUM_DOWNLOAD_UPDATEINFO: PkStatusEnum = 25;
pub const PK_STATUS_ENUM_REPACKAGING: PkStatusEnum = 26;
pub const PK_STATUS_ENUM_LOADING_CACHE: PkStatusEnum = 27;
pub const PK_STATUS_ENUM_SCAN_APPLICATIONS: PkStatusEnum = 28;
pub const PK_STATUS_ENUM_GENERATE_PACKAGE_LIST: PkStatusEnum = 29;
pub const PK_STATUS_ENUM_WAITING_FOR_LOCK: PkStatusEnum = 30;
pub const PK_STATUS_ENUM_WAITING_FOR_AUTH: PkStatusEnum = 31;
pub const PK_STATUS_ENUM_SCAN_PROCESS_LIST: PkStatusEnum = 32;
pub const PK_STATUS_ENUM_CHECK_EXECUTABLE_FILES: PkStatusEnum = 33;
pub const PK_STATUS_ENUM_CHECK_LIBRARIES: PkStatusEnum = 34;
pub const PK_STATUS_ENUM_COPY_FILES: PkStatusEnum = 35;
pub const PK_STATUS_ENUM_RUN_HOOK: PkStatusEnum = 36;
pub const PK_STATUS_ENUM_LAST: PkStatusEnum = 37;

pub type PkTransactionFlagEnum = c_int;
pub const PK_TRANSACTION_FLAG_ENUM_NONE: PkTransactionFlagEnum = 0;
pub const PK_TRANSACTION_FLAG_ENUM_ONLY_TRUSTED: PkTransactionFlagEnum = 1;
pub const PK_TRANSACTION_FLAG_ENUM_SIMULATE: PkTransactionFlagEnum = 2;
pub const PK_TRANSACTION_FLAG_ENUM_ONLY_DOWNLOAD: PkTransactionFlagEnum = 3;
pub const PK_TRANSACTION_FLAG_ENUM_ALLOW_REINSTALL: PkTransactionFlagEnum = 4;
pub const PK_TRANSACTION_FLAG_ENUM_JUST_REINSTALL: PkTransactionFlagEnum = 5;
pub const PK_TRANSACTION_FLAG_ENUM_ALLOW_DOWNGRADE: PkTransactionFlagEnum = 6;
pub const PK_TRANSACTION_FLAG_ENUM_LAST: PkTransactionFlagEnum = 7;

pub type PkUpdateStateEnum = c_int;
pub const PK_UPDATE_STATE_ENUM_UNKNOWN: PkUpdateStateEnum = 0;
pub const PK_UPDATE_STATE_ENUM_STABLE: PkUpdateStateEnum = 1;
pub const PK_UPDATE_STATE_ENUM_UNSTABLE: PkUpdateStateEnum = 2;
pub const PK_UPDATE_STATE_ENUM_TESTING: PkUpdateStateEnum = 3;
pub const PK_UPDATE_STATE_ENUM_LAST: PkUpdateStateEnum = 4;

pub type PkUpgradeKindEnum = c_int;
pub const PK_UPGRADE_KIND_ENUM_UNKNOWN: PkUpgradeKindEnum = 0;
pub const PK_UPGRADE_KIND_ENUM_MINIMAL: PkUpgradeKindEnum = 1;
pub const PK_UPGRADE_KIND_ENUM_DEFAULT: PkUpgradeKindEnum = 2;
pub const PK_UPGRADE_KIND_ENUM_COMPLETE: PkUpgradeKindEnum = 3;
pub const PK_UPGRADE_KIND_ENUM_LAST: PkUpgradeKindEnum = 4;

// Constants
pub const PK_DBUS_INTERFACE: *const c_char =
    b"org.freedesktop.PackageKit\0" as *const u8 as *const c_char;
pub const PK_DBUS_INTERFACE_OFFLINE: *const c_char =
    b"org.freedesktop.PackageKit.Offline\0" as *const u8 as *const c_char;
pub const PK_DBUS_INTERFACE_TRANSACTION: *const c_char =
    b"org.freedesktop.PackageKit.Transaction\0" as *const u8 as *const c_char;
pub const PK_DBUS_PATH: *const c_char =
    b"/org/freedesktop/PackageKit\0" as *const u8 as *const c_char;
pub const PK_DBUS_SERVICE: *const c_char =
    b"org.freedesktop.PackageKit\0" as *const u8 as *const c_char;
pub const PK_DESKTOP_DEFAULT_APPLICATION_DIR: *const c_char =
    b"/usr/share/applications\0" as *const u8 as *const c_char;
pub const PK_MAJOR_VERSION: c_int = 1;
pub const PK_MICRO_VERSION: c_int = 2;
pub const PK_MINOR_VERSION: c_int = 2;
pub const PK_PACKAGE_IDS_DELIM: *const c_char = b"&\0" as *const u8 as *const c_char;
pub const PK_PACKAGE_ID_ARCH: c_int = 2;
pub const PK_PACKAGE_ID_DATA: c_int = 3;
pub const PK_PACKAGE_ID_NAME: c_int = 0;
pub const PK_PACKAGE_ID_VERSION: c_int = 1;
pub const PK_SYSTEM_PACKAGE_CACHE_FILENAME: *const c_char =
    b"/var/lib/PackageKit/package-cache.db\0" as *const u8 as *const c_char;
pub const PK_SYSTEM_PACKAGE_LIST_FILENAME: *const c_char =
    b"/var/lib/PackageKit/system.package-list\0" as *const u8 as *const c_char;

// Callbacks
pub type PkPackageSackFilterFunc =
    Option<unsafe extern "C" fn(*mut PkPackage, gpointer) -> gboolean>;
pub type PkProgressCallback =
    Option<unsafe extern "C" fn(*mut PkProgress, PkProgressType, gpointer)>;

// Records
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkCategoryClass {
    pub parent_class: PkSourceClass,
    pub _pk_reserved1: Option<unsafe extern "C" fn()>,
    pub _pk_reserved2: Option<unsafe extern "C" fn()>,
    pub _pk_reserved3: Option<unsafe extern "C" fn()>,
    pub _pk_reserved4: Option<unsafe extern "C" fn()>,
    pub _pk_reserved5: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for PkCategoryClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkCategoryClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("_pk_reserved1", &self._pk_reserved1)
            .field("_pk_reserved2", &self._pk_reserved2)
            .field("_pk_reserved3", &self._pk_reserved3)
            .field("_pk_reserved4", &self._pk_reserved4)
            .field("_pk_reserved5", &self._pk_reserved5)
            .finish()
    }
}

#[repr(C)]
pub struct _PkCategoryPrivate(c_void);

pub type PkCategoryPrivate = *mut _PkCategoryPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkClientClass {
    pub parent_class: gobject::GObjectClass,
    pub changed: Option<unsafe extern "C" fn(*mut PkClient)>,
    pub _pk_reserved1: Option<unsafe extern "C" fn()>,
    pub _pk_reserved2: Option<unsafe extern "C" fn()>,
    pub _pk_reserved3: Option<unsafe extern "C" fn()>,
    pub _pk_reserved4: Option<unsafe extern "C" fn()>,
    pub _pk_reserved5: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for PkClientClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkClientClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("changed", &self.changed)
            .field("_pk_reserved1", &self._pk_reserved1)
            .field("_pk_reserved2", &self._pk_reserved2)
            .field("_pk_reserved3", &self._pk_reserved3)
            .field("_pk_reserved4", &self._pk_reserved4)
            .field("_pk_reserved5", &self._pk_reserved5)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkClientHelperClass {
    pub parent_class: gobject::GObjectClass,
    pub _pk_reserved1: Option<unsafe extern "C" fn()>,
    pub _pk_reserved2: Option<unsafe extern "C" fn()>,
    pub _pk_reserved3: Option<unsafe extern "C" fn()>,
    pub _pk_reserved4: Option<unsafe extern "C" fn()>,
    pub _pk_reserved5: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for PkClientHelperClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkClientHelperClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("_pk_reserved1", &self._pk_reserved1)
            .field("_pk_reserved2", &self._pk_reserved2)
            .field("_pk_reserved3", &self._pk_reserved3)
            .field("_pk_reserved4", &self._pk_reserved4)
            .field("_pk_reserved5", &self._pk_reserved5)
            .finish()
    }
}

#[repr(C)]
pub struct _PkClientHelperPrivate(c_void);

pub type PkClientHelperPrivate = *mut _PkClientHelperPrivate;

#[repr(C)]
pub struct _PkClientPrivate(c_void);

pub type PkClientPrivate = *mut _PkClientPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkControlClass {
    pub parent_class: gobject::GObjectClass,
    pub transaction_list_changed: Option<unsafe extern "C" fn(*mut PkControl, *mut *mut c_char)>,
    pub updates_changed: Option<unsafe extern "C" fn(*mut PkControl)>,
    pub repo_list_changed: Option<unsafe extern "C" fn(*mut PkControl)>,
    pub network_state_changed: Option<unsafe extern "C" fn(*mut PkControl)>,
    pub restart_schedule: Option<unsafe extern "C" fn(*mut PkControl)>,
    pub locked: Option<unsafe extern "C" fn(*mut PkControl, gboolean)>,
    pub connection_changed: Option<unsafe extern "C" fn(*mut PkControl, gboolean)>,
    pub _pk_reserved1: Option<unsafe extern "C" fn()>,
    pub _pk_reserved2: Option<unsafe extern "C" fn()>,
    pub _pk_reserved3: Option<unsafe extern "C" fn()>,
    pub _pk_reserved4: Option<unsafe extern "C" fn()>,
    pub _pk_reserved5: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for PkControlClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkControlClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("transaction_list_changed", &self.transaction_list_changed)
            .field("updates_changed", &self.updates_changed)
            .field("repo_list_changed", &self.repo_list_changed)
            .field("network_state_changed", &self.network_state_changed)
            .field("restart_schedule", &self.restart_schedule)
            .field("locked", &self.locked)
            .field("connection_changed", &self.connection_changed)
            .field("_pk_reserved1", &self._pk_reserved1)
            .field("_pk_reserved2", &self._pk_reserved2)
            .field("_pk_reserved3", &self._pk_reserved3)
            .field("_pk_reserved4", &self._pk_reserved4)
            .field("_pk_reserved5", &self._pk_reserved5)
            .finish()
    }
}

#[repr(C)]
pub struct _PkControlPrivate(c_void);

pub type PkControlPrivate = *mut _PkControlPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkDesktopClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for PkDesktopClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkDesktopClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
pub struct _PkDesktopPrivate(c_void);

pub type PkDesktopPrivate = *mut _PkDesktopPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkDetailsClass {
    pub parent_class: PkSourceClass,
    pub _pk_reserved1: Option<unsafe extern "C" fn()>,
    pub _pk_reserved2: Option<unsafe extern "C" fn()>,
    pub _pk_reserved3: Option<unsafe extern "C" fn()>,
    pub _pk_reserved4: Option<unsafe extern "C" fn()>,
    pub _pk_reserved5: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for PkDetailsClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkDetailsClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("_pk_reserved1", &self._pk_reserved1)
            .field("_pk_reserved2", &self._pk_reserved2)
            .field("_pk_reserved3", &self._pk_reserved3)
            .field("_pk_reserved4", &self._pk_reserved4)
            .field("_pk_reserved5", &self._pk_reserved5)
            .finish()
    }
}

#[repr(C)]
pub struct _PkDetailsPrivate(c_void);

pub type PkDetailsPrivate = *mut _PkDetailsPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkDistroUpgradeClass {
    pub parent_class: PkSourceClass,
    pub _pk_reserved1: Option<unsafe extern "C" fn()>,
    pub _pk_reserved2: Option<unsafe extern "C" fn()>,
    pub _pk_reserved3: Option<unsafe extern "C" fn()>,
    pub _pk_reserved4: Option<unsafe extern "C" fn()>,
    pub _pk_reserved5: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for PkDistroUpgradeClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkDistroUpgradeClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("_pk_reserved1", &self._pk_reserved1)
            .field("_pk_reserved2", &self._pk_reserved2)
            .field("_pk_reserved3", &self._pk_reserved3)
            .field("_pk_reserved4", &self._pk_reserved4)
            .field("_pk_reserved5", &self._pk_reserved5)
            .finish()
    }
}

#[repr(C)]
pub struct _PkDistroUpgradePrivate(c_void);

pub type PkDistroUpgradePrivate = *mut _PkDistroUpgradePrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkEnumMatch {
    pub value: c_uint,
    pub string: *const c_char,
}

impl ::std::fmt::Debug for PkEnumMatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkEnumMatch @ {:p}", self))
            .field("value", &self.value)
            .field("string", &self.string)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkErrorClass {
    pub parent_class: PkSourceClass,
    pub _pk_reserved1: Option<unsafe extern "C" fn()>,
    pub _pk_reserved2: Option<unsafe extern "C" fn()>,
    pub _pk_reserved3: Option<unsafe extern "C" fn()>,
    pub _pk_reserved4: Option<unsafe extern "C" fn()>,
    pub _pk_reserved5: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for PkErrorClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkErrorClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("_pk_reserved1", &self._pk_reserved1)
            .field("_pk_reserved2", &self._pk_reserved2)
            .field("_pk_reserved3", &self._pk_reserved3)
            .field("_pk_reserved4", &self._pk_reserved4)
            .field("_pk_reserved5", &self._pk_reserved5)
            .finish()
    }
}

#[repr(C)]
pub struct _PkErrorPrivate(c_void);

pub type PkErrorPrivate = *mut _PkErrorPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkEulaRequiredClass {
    pub parent_class: PkSourceClass,
    pub _pk_reserved1: Option<unsafe extern "C" fn()>,
    pub _pk_reserved2: Option<unsafe extern "C" fn()>,
    pub _pk_reserved3: Option<unsafe extern "C" fn()>,
    pub _pk_reserved4: Option<unsafe extern "C" fn()>,
    pub _pk_reserved5: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for PkEulaRequiredClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkEulaRequiredClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("_pk_reserved1", &self._pk_reserved1)
            .field("_pk_reserved2", &self._pk_reserved2)
            .field("_pk_reserved3", &self._pk_reserved3)
            .field("_pk_reserved4", &self._pk_reserved4)
            .field("_pk_reserved5", &self._pk_reserved5)
            .finish()
    }
}

#[repr(C)]
pub struct _PkEulaRequiredPrivate(c_void);

pub type PkEulaRequiredPrivate = *mut _PkEulaRequiredPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkFilesClass {
    pub parent_class: PkSourceClass,
    pub _pk_reserved1: Option<unsafe extern "C" fn()>,
    pub _pk_reserved2: Option<unsafe extern "C" fn()>,
    pub _pk_reserved3: Option<unsafe extern "C" fn()>,
    pub _pk_reserved4: Option<unsafe extern "C" fn()>,
    pub _pk_reserved5: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for PkFilesClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkFilesClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("_pk_reserved1", &self._pk_reserved1)
            .field("_pk_reserved2", &self._pk_reserved2)
            .field("_pk_reserved3", &self._pk_reserved3)
            .field("_pk_reserved4", &self._pk_reserved4)
            .field("_pk_reserved5", &self._pk_reserved5)
            .finish()
    }
}

#[repr(C)]
pub struct _PkFilesPrivate(c_void);

pub type PkFilesPrivate = *mut _PkFilesPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkItemProgressClass {
    pub parent_class: PkSourceClass,
    pub _pk_reserved1: Option<unsafe extern "C" fn()>,
    pub _pk_reserved2: Option<unsafe extern "C" fn()>,
    pub _pk_reserved3: Option<unsafe extern "C" fn()>,
    pub _pk_reserved4: Option<unsafe extern "C" fn()>,
    pub _pk_reserved5: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for PkItemProgressClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkItemProgressClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("_pk_reserved1", &self._pk_reserved1)
            .field("_pk_reserved2", &self._pk_reserved2)
            .field("_pk_reserved3", &self._pk_reserved3)
            .field("_pk_reserved4", &self._pk_reserved4)
            .field("_pk_reserved5", &self._pk_reserved5)
            .finish()
    }
}

#[repr(C)]
pub struct _PkItemProgressPrivate(c_void);

pub type PkItemProgressPrivate = *mut _PkItemProgressPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkMediaChangeRequiredClass {
    pub parent_class: PkSourceClass,
    pub _pk_reserved1: Option<unsafe extern "C" fn()>,
    pub _pk_reserved2: Option<unsafe extern "C" fn()>,
    pub _pk_reserved3: Option<unsafe extern "C" fn()>,
    pub _pk_reserved4: Option<unsafe extern "C" fn()>,
    pub _pk_reserved5: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for PkMediaChangeRequiredClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkMediaChangeRequiredClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("_pk_reserved1", &self._pk_reserved1)
            .field("_pk_reserved2", &self._pk_reserved2)
            .field("_pk_reserved3", &self._pk_reserved3)
            .field("_pk_reserved4", &self._pk_reserved4)
            .field("_pk_reserved5", &self._pk_reserved5)
            .finish()
    }
}

#[repr(C)]
pub struct _PkMediaChangeRequiredPrivate(c_void);

pub type PkMediaChangeRequiredPrivate = *mut _PkMediaChangeRequiredPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkPackageClass {
    pub parent_class: PkSourceClass,
    pub changed: Option<unsafe extern "C" fn(*mut PkPackage)>,
    pub _pk_reserved1: Option<unsafe extern "C" fn()>,
    pub _pk_reserved2: Option<unsafe extern "C" fn()>,
    pub _pk_reserved3: Option<unsafe extern "C" fn()>,
    pub _pk_reserved4: Option<unsafe extern "C" fn()>,
    pub _pk_reserved5: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for PkPackageClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkPackageClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("changed", &self.changed)
            .field("_pk_reserved1", &self._pk_reserved1)
            .field("_pk_reserved2", &self._pk_reserved2)
            .field("_pk_reserved3", &self._pk_reserved3)
            .field("_pk_reserved4", &self._pk_reserved4)
            .field("_pk_reserved5", &self._pk_reserved5)
            .finish()
    }
}

#[repr(C)]
pub struct _PkPackagePrivate(c_void);

pub type PkPackagePrivate = *mut _PkPackagePrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkPackageSackClass {
    pub parent_class: gobject::GObjectClass,
    pub changed: Option<unsafe extern "C" fn(*mut PkPackageSack)>,
    pub _pk_reserved1: Option<unsafe extern "C" fn()>,
    pub _pk_reserved2: Option<unsafe extern "C" fn()>,
    pub _pk_reserved3: Option<unsafe extern "C" fn()>,
    pub _pk_reserved4: Option<unsafe extern "C" fn()>,
    pub _pk_reserved5: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for PkPackageSackClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkPackageSackClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("changed", &self.changed)
            .field("_pk_reserved1", &self._pk_reserved1)
            .field("_pk_reserved2", &self._pk_reserved2)
            .field("_pk_reserved3", &self._pk_reserved3)
            .field("_pk_reserved4", &self._pk_reserved4)
            .field("_pk_reserved5", &self._pk_reserved5)
            .finish()
    }
}

#[repr(C)]
pub struct _PkPackageSackPrivate(c_void);

pub type PkPackageSackPrivate = *mut _PkPackageSackPrivate;

#[repr(C)]
pub struct _PkPackageSackResults(c_void);

pub type PkPackageSackResults = *mut _PkPackageSackResults;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkProgressClass {
    pub parent_class: gobject::GObjectClass,
    pub _pk_reserved1: Option<unsafe extern "C" fn()>,
    pub _pk_reserved2: Option<unsafe extern "C" fn()>,
    pub _pk_reserved3: Option<unsafe extern "C" fn()>,
    pub _pk_reserved4: Option<unsafe extern "C" fn()>,
    pub _pk_reserved5: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for PkProgressClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkProgressClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("_pk_reserved1", &self._pk_reserved1)
            .field("_pk_reserved2", &self._pk_reserved2)
            .field("_pk_reserved3", &self._pk_reserved3)
            .field("_pk_reserved4", &self._pk_reserved4)
            .field("_pk_reserved5", &self._pk_reserved5)
            .finish()
    }
}

#[repr(C)]
pub struct _PkProgressPrivate(c_void);

pub type PkProgressPrivate = *mut _PkProgressPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkRepoDetailClass {
    pub parent_class: PkSourceClass,
    pub _pk_reserved1: Option<unsafe extern "C" fn()>,
    pub _pk_reserved2: Option<unsafe extern "C" fn()>,
    pub _pk_reserved3: Option<unsafe extern "C" fn()>,
    pub _pk_reserved4: Option<unsafe extern "C" fn()>,
    pub _pk_reserved5: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for PkRepoDetailClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkRepoDetailClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("_pk_reserved1", &self._pk_reserved1)
            .field("_pk_reserved2", &self._pk_reserved2)
            .field("_pk_reserved3", &self._pk_reserved3)
            .field("_pk_reserved4", &self._pk_reserved4)
            .field("_pk_reserved5", &self._pk_reserved5)
            .finish()
    }
}

#[repr(C)]
pub struct _PkRepoDetailPrivate(c_void);

pub type PkRepoDetailPrivate = *mut _PkRepoDetailPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkRepoSignatureRequiredClass {
    pub parent_class: PkSourceClass,
    pub _pk_reserved1: Option<unsafe extern "C" fn()>,
    pub _pk_reserved2: Option<unsafe extern "C" fn()>,
    pub _pk_reserved3: Option<unsafe extern "C" fn()>,
    pub _pk_reserved4: Option<unsafe extern "C" fn()>,
    pub _pk_reserved5: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for PkRepoSignatureRequiredClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkRepoSignatureRequiredClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("_pk_reserved1", &self._pk_reserved1)
            .field("_pk_reserved2", &self._pk_reserved2)
            .field("_pk_reserved3", &self._pk_reserved3)
            .field("_pk_reserved4", &self._pk_reserved4)
            .field("_pk_reserved5", &self._pk_reserved5)
            .finish()
    }
}

#[repr(C)]
pub struct _PkRepoSignatureRequiredPrivate(c_void);

pub type PkRepoSignatureRequiredPrivate = *mut _PkRepoSignatureRequiredPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkRequireRestartClass {
    pub parent_class: PkSourceClass,
    pub _pk_reserved1: Option<unsafe extern "C" fn()>,
    pub _pk_reserved2: Option<unsafe extern "C" fn()>,
    pub _pk_reserved3: Option<unsafe extern "C" fn()>,
    pub _pk_reserved4: Option<unsafe extern "C" fn()>,
    pub _pk_reserved5: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for PkRequireRestartClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkRequireRestartClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("_pk_reserved1", &self._pk_reserved1)
            .field("_pk_reserved2", &self._pk_reserved2)
            .field("_pk_reserved3", &self._pk_reserved3)
            .field("_pk_reserved4", &self._pk_reserved4)
            .field("_pk_reserved5", &self._pk_reserved5)
            .finish()
    }
}

#[repr(C)]
pub struct _PkRequireRestartPrivate(c_void);

pub type PkRequireRestartPrivate = *mut _PkRequireRestartPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkResultsClass {
    pub parent_class: gobject::GObjectClass,
    pub _pk_reserved1: Option<unsafe extern "C" fn()>,
    pub _pk_reserved2: Option<unsafe extern "C" fn()>,
    pub _pk_reserved3: Option<unsafe extern "C" fn()>,
    pub _pk_reserved4: Option<unsafe extern "C" fn()>,
    pub _pk_reserved5: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for PkResultsClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkResultsClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("_pk_reserved1", &self._pk_reserved1)
            .field("_pk_reserved2", &self._pk_reserved2)
            .field("_pk_reserved3", &self._pk_reserved3)
            .field("_pk_reserved4", &self._pk_reserved4)
            .field("_pk_reserved5", &self._pk_reserved5)
            .finish()
    }
}

#[repr(C)]
pub struct _PkResultsPrivate(c_void);

pub type PkResultsPrivate = *mut _PkResultsPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkSourceClass {
    pub parent_class: gobject::GObjectClass,
    pub _pk_reserved1: Option<unsafe extern "C" fn()>,
    pub _pk_reserved2: Option<unsafe extern "C" fn()>,
    pub _pk_reserved3: Option<unsafe extern "C" fn()>,
    pub _pk_reserved4: Option<unsafe extern "C" fn()>,
    pub _pk_reserved5: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for PkSourceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkSourceClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("_pk_reserved1", &self._pk_reserved1)
            .field("_pk_reserved2", &self._pk_reserved2)
            .field("_pk_reserved3", &self._pk_reserved3)
            .field("_pk_reserved4", &self._pk_reserved4)
            .field("_pk_reserved5", &self._pk_reserved5)
            .finish()
    }
}

#[repr(C)]
pub struct _PkSourcePrivate(c_void);

pub type PkSourcePrivate = *mut _PkSourcePrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkTaskClass {
    pub parent_class: PkClientClass,
    pub untrusted_question: Option<unsafe extern "C" fn(*mut PkTask, c_uint, *mut PkResults)>,
    pub key_question: Option<unsafe extern "C" fn(*mut PkTask, c_uint, *mut PkResults)>,
    pub eula_question: Option<unsafe extern "C" fn(*mut PkTask, c_uint, *mut PkResults)>,
    pub media_change_question: Option<unsafe extern "C" fn(*mut PkTask, c_uint, *mut PkResults)>,
    pub simulate_question: Option<unsafe extern "C" fn(*mut PkTask, c_uint, *mut PkResults)>,
    pub repair_question: Option<unsafe extern "C" fn(*mut PkTask, c_uint, *mut PkResults)>,
    pub _pk_reserved1: Option<unsafe extern "C" fn()>,
    pub _pk_reserved2: Option<unsafe extern "C" fn()>,
    pub _pk_reserved3: Option<unsafe extern "C" fn()>,
    pub _pk_reserved4: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for PkTaskClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkTaskClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("untrusted_question", &self.untrusted_question)
            .field("key_question", &self.key_question)
            .field("eula_question", &self.eula_question)
            .field("media_change_question", &self.media_change_question)
            .field("simulate_question", &self.simulate_question)
            .field("repair_question", &self.repair_question)
            .field("_pk_reserved1", &self._pk_reserved1)
            .field("_pk_reserved2", &self._pk_reserved2)
            .field("_pk_reserved3", &self._pk_reserved3)
            .field("_pk_reserved4", &self._pk_reserved4)
            .finish()
    }
}

#[repr(C)]
pub struct _PkTaskPrivate(c_void);

pub type PkTaskPrivate = *mut _PkTaskPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkTransactionListClass {
    pub parent_class: gobject::GObjectClass,
    pub added: Option<unsafe extern "C" fn(*mut PkTransactionList, *const c_char)>,
    pub removed: Option<unsafe extern "C" fn(*mut PkTransactionList, *const c_char)>,
}

impl ::std::fmt::Debug for PkTransactionListClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkTransactionListClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("added", &self.added)
            .field("removed", &self.removed)
            .finish()
    }
}

#[repr(C)]
pub struct _PkTransactionListPrivate(c_void);

pub type PkTransactionListPrivate = *mut _PkTransactionListPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkTransactionPastClass {
    pub parent_class: PkSourceClass,
    pub _pk_reserved1: Option<unsafe extern "C" fn()>,
    pub _pk_reserved2: Option<unsafe extern "C" fn()>,
    pub _pk_reserved3: Option<unsafe extern "C" fn()>,
    pub _pk_reserved4: Option<unsafe extern "C" fn()>,
    pub _pk_reserved5: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for PkTransactionPastClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkTransactionPastClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("_pk_reserved1", &self._pk_reserved1)
            .field("_pk_reserved2", &self._pk_reserved2)
            .field("_pk_reserved3", &self._pk_reserved3)
            .field("_pk_reserved4", &self._pk_reserved4)
            .field("_pk_reserved5", &self._pk_reserved5)
            .finish()
    }
}

#[repr(C)]
pub struct _PkTransactionPastPrivate(c_void);

pub type PkTransactionPastPrivate = *mut _PkTransactionPastPrivate;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkUpdateDetailClass {
    pub parent_class: PkSourceClass,
    pub _pk_reserved1: Option<unsafe extern "C" fn()>,
    pub _pk_reserved2: Option<unsafe extern "C" fn()>,
    pub _pk_reserved3: Option<unsafe extern "C" fn()>,
    pub _pk_reserved4: Option<unsafe extern "C" fn()>,
    pub _pk_reserved5: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for PkUpdateDetailClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkUpdateDetailClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("_pk_reserved1", &self._pk_reserved1)
            .field("_pk_reserved2", &self._pk_reserved2)
            .field("_pk_reserved3", &self._pk_reserved3)
            .field("_pk_reserved4", &self._pk_reserved4)
            .field("_pk_reserved5", &self._pk_reserved5)
            .finish()
    }
}

#[repr(C)]
pub struct _PkUpdateDetailPrivate(c_void);

pub type PkUpdateDetailPrivate = *mut _PkUpdateDetailPrivate;

// Classes
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkCategory {
    pub parent: PkSource,
    pub priv_: *mut PkCategoryPrivate,
}

impl ::std::fmt::Debug for PkCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkCategory @ {:p}", self))
            .field("parent", &self.parent)
            .field("priv_", &self.priv_)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkClient {
    pub parent: gobject::GObject,
    pub priv_: *mut PkClientPrivate,
}

impl ::std::fmt::Debug for PkClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkClient @ {:p}", self))
            .field("parent", &self.parent)
            .field("priv_", &self.priv_)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkClientHelper {
    pub parent: gobject::GObject,
    pub priv_: *mut PkClientHelperPrivate,
}

impl ::std::fmt::Debug for PkClientHelper {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkClientHelper @ {:p}", self))
            .field("parent", &self.parent)
            .field("priv_", &self.priv_)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkControl {
    pub parent: gobject::GObject,
    pub priv_: *mut PkControlPrivate,
}

impl ::std::fmt::Debug for PkControl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkControl @ {:p}", self))
            .field("parent", &self.parent)
            .field("priv_", &self.priv_)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkDesktop {
    pub parent: gobject::GObject,
    pub priv_: *mut PkDesktopPrivate,
}

impl ::std::fmt::Debug for PkDesktop {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkDesktop @ {:p}", self))
            .field("parent", &self.parent)
            .field("priv_", &self.priv_)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkDetails {
    pub parent: PkSource,
    pub priv_: *mut PkDetailsPrivate,
}

impl ::std::fmt::Debug for PkDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkDetails @ {:p}", self))
            .field("parent", &self.parent)
            .field("priv_", &self.priv_)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkDistroUpgrade {
    pub parent: PkSource,
    pub priv_: *mut PkDistroUpgradePrivate,
}

impl ::std::fmt::Debug for PkDistroUpgrade {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkDistroUpgrade @ {:p}", self))
            .field("parent", &self.parent)
            .field("priv_", &self.priv_)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkError {
    pub parent: PkSource,
    pub priv_: *mut PkErrorPrivate,
}

impl ::std::fmt::Debug for PkError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkError @ {:p}", self))
            .field("parent", &self.parent)
            .field("priv_", &self.priv_)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkEulaRequired {
    pub parent: PkSource,
    pub priv_: *mut PkEulaRequiredPrivate,
}

impl ::std::fmt::Debug for PkEulaRequired {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkEulaRequired @ {:p}", self))
            .field("parent", &self.parent)
            .field("priv_", &self.priv_)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkFiles {
    pub parent: PkSource,
    pub priv_: *mut PkFilesPrivate,
}

impl ::std::fmt::Debug for PkFiles {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkFiles @ {:p}", self))
            .field("parent", &self.parent)
            .field("priv_", &self.priv_)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkItemProgress {
    pub parent: PkSource,
    pub priv_: *mut PkItemProgressPrivate,
}

impl ::std::fmt::Debug for PkItemProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkItemProgress @ {:p}", self))
            .field("parent", &self.parent)
            .field("priv_", &self.priv_)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkMediaChangeRequired {
    pub parent: PkSource,
    pub priv_: *mut PkMediaChangeRequiredPrivate,
}

impl ::std::fmt::Debug for PkMediaChangeRequired {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkMediaChangeRequired @ {:p}", self))
            .field("parent", &self.parent)
            .field("priv_", &self.priv_)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkPackage {
    pub parent: PkSource,
    pub priv_: *mut PkPackagePrivate,
}

impl ::std::fmt::Debug for PkPackage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkPackage @ {:p}", self))
            .field("parent", &self.parent)
            .field("priv_", &self.priv_)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkPackageSack {
    pub parent: gobject::GObject,
    pub priv_: *mut PkPackageSackPrivate,
}

impl ::std::fmt::Debug for PkPackageSack {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkPackageSack @ {:p}", self))
            .field("parent", &self.parent)
            .field("priv_", &self.priv_)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkProgress {
    pub parent: gobject::GObject,
    pub priv_: *mut PkProgressPrivate,
}

impl ::std::fmt::Debug for PkProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkProgress @ {:p}", self))
            .field("parent", &self.parent)
            .field("priv_", &self.priv_)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkRepoDetail {
    pub parent: PkSource,
    pub priv_: *mut PkRepoDetailPrivate,
}

impl ::std::fmt::Debug for PkRepoDetail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkRepoDetail @ {:p}", self))
            .field("parent", &self.parent)
            .field("priv_", &self.priv_)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkRepoSignatureRequired {
    pub parent: PkSource,
    pub priv_: *mut PkRepoSignatureRequiredPrivate,
}

impl ::std::fmt::Debug for PkRepoSignatureRequired {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkRepoSignatureRequired @ {:p}", self))
            .field("parent", &self.parent)
            .field("priv_", &self.priv_)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkRequireRestart {
    pub parent: PkSource,
    pub priv_: *mut PkRequireRestartPrivate,
}

impl ::std::fmt::Debug for PkRequireRestart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkRequireRestart @ {:p}", self))
            .field("parent", &self.parent)
            .field("priv_", &self.priv_)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkResults {
    pub parent: gobject::GObject,
    pub priv_: *mut PkResultsPrivate,
}

impl ::std::fmt::Debug for PkResults {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkResults @ {:p}", self))
            .field("parent", &self.parent)
            .field("priv_", &self.priv_)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkSource {
    pub parent: gobject::GObject,
    pub priv_: *mut PkSourcePrivate,
}

impl ::std::fmt::Debug for PkSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkSource @ {:p}", self))
            .field("parent", &self.parent)
            .field("priv_", &self.priv_)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkTask {
    pub parent: PkClient,
    pub priv_: *mut PkTaskPrivate,
}

impl ::std::fmt::Debug for PkTask {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkTask @ {:p}", self))
            .field("parent", &self.parent)
            .field("priv_", &self.priv_)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkTransactionList {
    pub parent: gobject::GObject,
    pub priv_: *mut PkTransactionListPrivate,
}

impl ::std::fmt::Debug for PkTransactionList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkTransactionList @ {:p}", self))
            .field("parent", &self.parent)
            .field("priv_", &self.priv_)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkTransactionPast {
    pub parent: PkSource,
    pub priv_: *mut PkTransactionPastPrivate,
}

impl ::std::fmt::Debug for PkTransactionPast {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkTransactionPast @ {:p}", self))
            .field("parent", &self.parent)
            .field("priv_", &self.priv_)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PkUpdateDetail {
    pub parent: PkSource,
    pub priv_: *mut PkUpdateDetailPrivate,
}

impl ::std::fmt::Debug for PkUpdateDetail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("PkUpdateDetail @ {:p}", self))
            .field("parent", &self.parent)
            .field("priv_", &self.priv_)
            .finish()
    }
}

#[link(name = "packagekit-glib2")]
extern "C" {

    //=========================================================================
    // PkAuthorizeEnum
    //=========================================================================
    pub fn pk_authorize_enum_get_type() -> GType;

    //=========================================================================
    // PkClientError
    //=========================================================================
    pub fn pk_client_error_get_type() -> GType;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_client_error_quark() -> glib::GQuark;

    //=========================================================================
    // PkControlError
    //=========================================================================
    pub fn pk_control_error_get_type() -> GType;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_control_error_quark() -> glib::GQuark;

    //=========================================================================
    // PkDistroUpgradeEnum
    //=========================================================================
    pub fn pk_distro_upgrade_enum_get_type() -> GType;
    #[cfg(any(feature = "v0_5", feature = "dox"))]
    pub fn pk_distro_upgrade_enum_from_string(upgrade: *const c_char) -> PkDistroUpgradeEnum;
    #[cfg(any(feature = "v0_5", feature = "dox"))]
    pub fn pk_distro_upgrade_enum_to_string(upgrade: PkDistroUpgradeEnum) -> *const c_char;

    //=========================================================================
    // PkErrorEnum
    //=========================================================================
    pub fn pk_error_enum_get_type() -> GType;
    #[cfg(any(feature = "v0_5", feature = "dox"))]
    pub fn pk_error_enum_from_string(code: *const c_char) -> PkErrorEnum;
    #[cfg(any(feature = "v0_5", feature = "dox"))]
    pub fn pk_error_enum_to_string(code: PkErrorEnum) -> *const c_char;

    //=========================================================================
    // PkExitEnum
    //=========================================================================
    pub fn pk_exit_enum_get_type() -> GType;
    #[cfg(any(feature = "v0_5", feature = "dox"))]
    pub fn pk_exit_enum_from_string(exit: *const c_char) -> PkExitEnum;
    #[cfg(any(feature = "v0_5", feature = "dox"))]
    pub fn pk_exit_enum_to_string(exit: PkExitEnum) -> *const c_char;

    //=========================================================================
    // PkFilterEnum
    //=========================================================================
    pub fn pk_filter_enum_get_type() -> GType;
    #[cfg(any(feature = "v0_5", feature = "dox"))]
    pub fn pk_filter_enum_from_string(filter: *const c_char) -> PkFilterEnum;
    #[cfg(any(feature = "v0_5", feature = "dox"))]
    pub fn pk_filter_enum_to_string(filter: PkFilterEnum) -> *const c_char;

    //=========================================================================
    // PkGroupEnum
    //=========================================================================
    pub fn pk_group_enum_get_type() -> GType;
    #[cfg(any(feature = "v0_5", feature = "dox"))]
    pub fn pk_group_enum_from_string(group: *const c_char) -> PkGroupEnum;
    #[cfg(any(feature = "v0_5", feature = "dox"))]
    pub fn pk_group_enum_to_string(group: PkGroupEnum) -> *const c_char;

    //=========================================================================
    // PkInfoEnum
    //=========================================================================
    pub fn pk_info_enum_get_type() -> GType;
    #[cfg(any(feature = "v0_5", feature = "dox"))]
    pub fn pk_info_enum_from_string(info: *const c_char) -> PkInfoEnum;
    #[cfg(any(feature = "v0_7_2", feature = "dox"))]
    pub fn pk_info_enum_to_localised_past(info: PkInfoEnum) -> *const c_char;
    #[cfg(any(feature = "v0_7_2", feature = "dox"))]
    pub fn pk_info_enum_to_localised_present(info: PkInfoEnum) -> *const c_char;
    #[cfg(any(feature = "v0_5", feature = "dox"))]
    pub fn pk_info_enum_to_string(info: PkInfoEnum) -> *const c_char;

    //=========================================================================
    // PkMediaTypeEnum
    //=========================================================================
    pub fn pk_media_type_enum_get_type() -> GType;
    #[cfg(any(feature = "v0_5", feature = "dox"))]
    pub fn pk_media_type_enum_from_string(media_type: *const c_char) -> PkMediaTypeEnum;
    #[cfg(any(feature = "v0_5", feature = "dox"))]
    pub fn pk_media_type_enum_to_string(media_type: PkMediaTypeEnum) -> *const c_char;

    //=========================================================================
    // PkNetworkEnum
    //=========================================================================
    pub fn pk_network_enum_get_type() -> GType;
    #[cfg(any(feature = "v0_5", feature = "dox"))]
    pub fn pk_network_enum_from_string(network: *const c_char) -> PkNetworkEnum;
    #[cfg(any(feature = "v0_5", feature = "dox"))]
    pub fn pk_network_enum_to_string(network: PkNetworkEnum) -> *const c_char;

    //=========================================================================
    // PkOfflineAction
    //=========================================================================
    pub fn pk_offline_action_get_type() -> GType;
    #[cfg(any(feature = "v0_9_6", feature = "dox"))]
    pub fn pk_offline_action_from_string(action: *const c_char) -> PkOfflineAction;
    #[cfg(any(feature = "v0_9_6", feature = "dox"))]
    pub fn pk_offline_action_to_string(action: PkOfflineAction) -> *const c_char;

    //=========================================================================
    // PkOfflineError
    //=========================================================================
    pub fn pk_offline_error_get_type() -> GType;
    #[cfg(any(feature = "v0_9_6", feature = "dox"))]
    pub fn pk_offline_error_quark() -> glib::GQuark;

    //=========================================================================
    // PkPackageSackSortType
    //=========================================================================
    pub fn pk_package_sack_sort_type_get_type() -> GType;

    //=========================================================================
    // PkProgressType
    //=========================================================================
    pub fn pk_progress_type_get_type() -> GType;

    //=========================================================================
    // PkRestartEnum
    //=========================================================================
    pub fn pk_restart_enum_get_type() -> GType;
    #[cfg(any(feature = "v0_5", feature = "dox"))]
    pub fn pk_restart_enum_from_string(restart: *const c_char) -> PkRestartEnum;
    #[cfg(any(feature = "v0_5", feature = "dox"))]
    pub fn pk_restart_enum_to_string(restart: PkRestartEnum) -> *const c_char;

    //=========================================================================
    // PkRoleEnum
    //=========================================================================
    pub fn pk_role_enum_get_type() -> GType;
    #[cfg(any(feature = "v0_5", feature = "dox"))]
    pub fn pk_role_enum_from_string(role: *const c_char) -> PkRoleEnum;
    #[cfg(any(feature = "v0_7_2", feature = "dox"))]
    pub fn pk_role_enum_to_localised_present(role: PkRoleEnum) -> *const c_char;
    #[cfg(any(feature = "v0_5", feature = "dox"))]
    pub fn pk_role_enum_to_string(role: PkRoleEnum) -> *const c_char;

    //=========================================================================
    // PkSigTypeEnum
    //=========================================================================
    pub fn pk_sig_type_enum_get_type() -> GType;
    pub fn pk_sig_type_enum_from_string(sig_type: *const c_char) -> PkSigTypeEnum;
    #[cfg(any(feature = "v0_5", feature = "dox"))]
    pub fn pk_sig_type_enum_to_string(sig_type: PkSigTypeEnum) -> *const c_char;

    //=========================================================================
    // PkStatusEnum
    //=========================================================================
    pub fn pk_status_enum_get_type() -> GType;
    #[cfg(any(feature = "v0_5", feature = "dox"))]
    pub fn pk_status_enum_from_string(status: *const c_char) -> PkStatusEnum;
    pub fn pk_status_enum_to_localised_text(status: PkStatusEnum) -> *const c_char;
    #[cfg(any(feature = "v0_5", feature = "dox"))]
    pub fn pk_status_enum_to_string(status: PkStatusEnum) -> *const c_char;

    //=========================================================================
    // PkTransactionFlagEnum
    //=========================================================================
    pub fn pk_transaction_flag_enum_get_type() -> GType;
    #[cfg(any(feature = "v0_8_1", feature = "dox"))]
    pub fn pk_transaction_flag_enum_from_string(
        transaction_flag: *const c_char,
    ) -> PkTransactionFlagEnum;
    #[cfg(any(feature = "v0_8_1", feature = "dox"))]
    pub fn pk_transaction_flag_enum_to_string(
        transaction_flag: PkTransactionFlagEnum,
    ) -> *const c_char;

    //=========================================================================
    // PkUpdateStateEnum
    //=========================================================================
    pub fn pk_update_state_enum_get_type() -> GType;
    #[cfg(any(feature = "v0_5", feature = "dox"))]
    pub fn pk_update_state_enum_from_string(update_state: *const c_char) -> PkUpdateStateEnum;
    #[cfg(any(feature = "v0_5", feature = "dox"))]
    pub fn pk_update_state_enum_to_string(update_state: PkUpdateStateEnum) -> *const c_char;

    //=========================================================================
    // PkUpgradeKindEnum
    //=========================================================================
    pub fn pk_upgrade_kind_enum_get_type() -> GType;
    #[cfg(any(feature = "v0_6_11", feature = "dox"))]
    pub fn pk_upgrade_kind_enum_from_string(upgrade_kind: *const c_char) -> PkUpgradeKindEnum;
    #[cfg(any(feature = "v0_6_11", feature = "dox"))]
    pub fn pk_upgrade_kind_enum_to_string(upgrade_kind: PkUpgradeKindEnum) -> *const c_char;

    //=========================================================================
    // PkCategory
    //=========================================================================
    pub fn pk_category_get_type() -> GType;
    #[cfg(any(feature = "v0_5_4", feature = "dox"))]
    pub fn pk_category_new() -> *mut PkCategory;
    #[cfg(any(feature = "v0_6_2", feature = "dox"))]
    pub fn pk_category_get_icon(category: *mut PkCategory) -> *const c_char;
    #[cfg(any(feature = "v0_6_2", feature = "dox"))]
    pub fn pk_category_get_id(category: *mut PkCategory) -> *const c_char;
    #[cfg(any(feature = "v0_6_2", feature = "dox"))]
    pub fn pk_category_get_name(category: *mut PkCategory) -> *const c_char;
    #[cfg(any(feature = "v0_6_2", feature = "dox"))]
    pub fn pk_category_get_parent_id(category: *mut PkCategory) -> *const c_char;
    #[cfg(any(feature = "v0_6_2", feature = "dox"))]
    pub fn pk_category_get_summary(category: *mut PkCategory) -> *const c_char;
    #[cfg(any(feature = "v0_6_2", feature = "dox"))]
    pub fn pk_category_set_icon(category: *mut PkCategory, icon: *const c_char);
    #[cfg(any(feature = "v0_6_2", feature = "dox"))]
    pub fn pk_category_set_id(category: *mut PkCategory, cat_id: *const c_char);
    #[cfg(any(feature = "v0_6_2", feature = "dox"))]
    pub fn pk_category_set_name(category: *mut PkCategory, name: *const c_char);
    #[cfg(any(feature = "v0_6_2", feature = "dox"))]
    pub fn pk_category_set_parent_id(category: *mut PkCategory, parent_id: *const c_char);
    #[cfg(any(feature = "v0_6_2", feature = "dox"))]
    pub fn pk_category_set_summary(category: *mut PkCategory, summary: *const c_char);

    //=========================================================================
    // PkClient
    //=========================================================================
    pub fn pk_client_get_type() -> GType;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_client_new() -> *mut PkClient;
    pub fn pk_client_create_helper_argv_envp(
        argv: *mut *mut *mut c_char,
        envp_out: *mut *mut *mut c_char,
    ) -> gboolean;
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_client_accept_eula(
        client: *mut PkClient,
        eula_id: *const c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_client_accept_eula_async(
        client: *mut PkClient,
        eula_id: *const c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_client_adopt(
        client: *mut PkClient,
        transaction_id: *const c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_client_adopt_async(
        client: *mut PkClient,
        transaction_id: *const c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_client_depends_on(
        client: *mut PkClient,
        filters: PkBitfield,
        package_ids: *mut *mut c_char,
        recursive: gboolean,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_client_depends_on_async(
        client: *mut PkClient,
        filters: PkBitfield,
        package_ids: *mut *mut c_char,
        recursive: gboolean,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_client_download_packages(
        client: *mut PkClient,
        package_ids: *mut *mut c_char,
        directory: *const c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_client_download_packages_async(
        client: *mut PkClient,
        package_ids: *mut *mut c_char,
        directory: *const c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_client_generic_finish(
        client: *mut PkClient,
        res: *mut gio::GAsyncResult,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_6_10", feature = "dox"))]
    pub fn pk_client_get_background(client: *mut PkClient) -> gboolean;
    #[cfg(any(feature = "v0_6_10", feature = "dox"))]
    pub fn pk_client_get_cache_age(client: *mut PkClient) -> c_uint;
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_client_get_categories(
        client: *mut PkClient,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_client_get_categories_async(
        client: *mut PkClient,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_client_get_details(
        client: *mut PkClient,
        package_ids: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_client_get_details_async(
        client: *mut PkClient,
        package_ids: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_8_17", feature = "dox"))]
    pub fn pk_client_get_details_local(
        client: *mut PkClient,
        files: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_8_17", feature = "dox"))]
    pub fn pk_client_get_details_local_async(
        client: *mut PkClient,
        files: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_client_get_distro_upgrades(
        client: *mut PkClient,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_client_get_distro_upgrades_async(
        client: *mut PkClient,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_client_get_files(
        client: *mut PkClient,
        package_ids: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_client_get_files_async(
        client: *mut PkClient,
        package_ids: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_9_1", feature = "dox"))]
    pub fn pk_client_get_files_local(
        client: *mut PkClient,
        files: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_9_1", feature = "dox"))]
    pub fn pk_client_get_files_local_async(
        client: *mut PkClient,
        files: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_6_10", feature = "dox"))]
    pub fn pk_client_get_idle(client: *mut PkClient) -> gboolean;
    #[cfg(any(feature = "v0_6_10", feature = "dox"))]
    pub fn pk_client_get_interactive(client: *mut PkClient) -> gboolean;
    #[cfg(any(feature = "v0_6_10", feature = "dox"))]
    pub fn pk_client_get_locale(client: *mut PkClient) -> *const c_char;
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_client_get_old_transactions(
        client: *mut PkClient,
        number: c_uint,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_client_get_old_transactions_async(
        client: *mut PkClient,
        number: c_uint,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_client_get_packages(
        client: *mut PkClient,
        filters: PkBitfield,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_client_get_packages_async(
        client: *mut PkClient,
        filters: PkBitfield,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_client_get_progress(
        client: *mut PkClient,
        transaction_id: *const c_char,
        cancellable: *mut gio::GCancellable,
        error: *mut *mut glib::GError,
    ) -> *mut PkProgress;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_client_get_progress_async(
        client: *mut PkClient,
        transaction_id: *const c_char,
        cancellable: *mut gio::GCancellable,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_client_get_progress_finish(
        client: *mut PkClient,
        res: *mut gio::GAsyncResult,
        error: *mut *mut glib::GError,
    ) -> *mut PkProgress;
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_client_get_repo_list(
        client: *mut PkClient,
        filters: PkBitfield,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_client_get_repo_list_async(
        client: *mut PkClient,
        filters: PkBitfield,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_client_get_update_detail(
        client: *mut PkClient,
        package_ids: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_client_get_update_detail_async(
        client: *mut PkClient,
        package_ids: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_client_get_updates(
        client: *mut PkClient,
        filters: PkBitfield,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_client_get_updates_async(
        client: *mut PkClient,
        filters: PkBitfield,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_8_1", feature = "dox"))]
    pub fn pk_client_install_files(
        client: *mut PkClient,
        transaction_flags: PkBitfield,
        files: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_8_1", feature = "dox"))]
    pub fn pk_client_install_files_async(
        client: *mut PkClient,
        transaction_flags: PkBitfield,
        files: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_8_1", feature = "dox"))]
    pub fn pk_client_install_packages(
        client: *mut PkClient,
        transaction_flags: PkBitfield,
        package_ids: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_8_1", feature = "dox"))]
    pub fn pk_client_install_packages_async(
        client: *mut PkClient,
        transaction_flags: PkBitfield,
        package_ids: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_client_install_signature(
        client: *mut PkClient,
        type_: PkSigTypeEnum,
        key_id: *const c_char,
        package_id: *const c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_client_install_signature_async(
        client: *mut PkClient,
        type_: PkSigTypeEnum,
        key_id: *const c_char,
        package_id: *const c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_client_refresh_cache(
        client: *mut PkClient,
        force: gboolean,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_client_refresh_cache_async(
        client: *mut PkClient,
        force: gboolean,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_8_1", feature = "dox"))]
    pub fn pk_client_remove_packages(
        client: *mut PkClient,
        transaction_flags: PkBitfield,
        package_ids: *mut *mut c_char,
        allow_deps: gboolean,
        autoremove: gboolean,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_8_1", feature = "dox"))]
    pub fn pk_client_remove_packages_async(
        client: *mut PkClient,
        transaction_flags: PkBitfield,
        package_ids: *mut *mut c_char,
        allow_deps: gboolean,
        autoremove: gboolean,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_8_1", feature = "dox"))]
    pub fn pk_client_repair_system(
        client: *mut PkClient,
        transaction_flags: PkBitfield,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_8_1", feature = "dox"))]
    pub fn pk_client_repair_system_async(
        client: *mut PkClient,
        transaction_flags: PkBitfield,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_client_repo_enable(
        client: *mut PkClient,
        repo_id: *const c_char,
        enabled: gboolean,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_client_repo_enable_async(
        client: *mut PkClient,
        repo_id: *const c_char,
        enabled: gboolean,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_9_1", feature = "dox"))]
    pub fn pk_client_repo_remove(
        client: *mut PkClient,
        transaction_flags: PkBitfield,
        repo_id: *const c_char,
        autoremove: gboolean,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_9_1", feature = "dox"))]
    pub fn pk_client_repo_remove_async(
        client: *mut PkClient,
        transaction_flags: PkBitfield,
        repo_id: *const c_char,
        autoremove: gboolean,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_client_repo_set_data(
        client: *mut PkClient,
        repo_id: *const c_char,
        parameter: *const c_char,
        value: *const c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_client_repo_set_data_async(
        client: *mut PkClient,
        repo_id: *const c_char,
        parameter: *const c_char,
        value: *const c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_client_required_by(
        client: *mut PkClient,
        filters: PkBitfield,
        package_ids: *mut *mut c_char,
        recursive: gboolean,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_client_required_by_async(
        client: *mut PkClient,
        filters: PkBitfield,
        package_ids: *mut *mut c_char,
        recursive: gboolean,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_client_resolve(
        client: *mut PkClient,
        filters: PkBitfield,
        packages: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_client_resolve_async(
        client: *mut PkClient,
        filters: PkBitfield,
        packages: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_5", feature = "dox"))]
    pub fn pk_client_search_details(
        client: *mut PkClient,
        filters: PkBitfield,
        values: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_5_5", feature = "dox"))]
    pub fn pk_client_search_details_async(
        client: *mut PkClient,
        filters: PkBitfield,
        values: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_5", feature = "dox"))]
    pub fn pk_client_search_files(
        client: *mut PkClient,
        filters: PkBitfield,
        values: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_5_5", feature = "dox"))]
    pub fn pk_client_search_files_async(
        client: *mut PkClient,
        filters: PkBitfield,
        values: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_5", feature = "dox"))]
    pub fn pk_client_search_groups(
        client: *mut PkClient,
        filters: PkBitfield,
        values: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_5_5", feature = "dox"))]
    pub fn pk_client_search_groups_async(
        client: *mut PkClient,
        filters: PkBitfield,
        values: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_5", feature = "dox"))]
    pub fn pk_client_search_names(
        client: *mut PkClient,
        filters: PkBitfield,
        values: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_5_5", feature = "dox"))]
    pub fn pk_client_search_names_async(
        client: *mut PkClient,
        filters: PkBitfield,
        values: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_6_10", feature = "dox"))]
    pub fn pk_client_set_background(client: *mut PkClient, background: gboolean);
    #[cfg(any(feature = "v0_6_10", feature = "dox"))]
    pub fn pk_client_set_cache_age(client: *mut PkClient, cache_age: c_uint);
    #[cfg(any(feature = "v0_6_10", feature = "dox"))]
    pub fn pk_client_set_interactive(client: *mut PkClient, interactive: gboolean);
    #[cfg(any(feature = "v0_6_10", feature = "dox"))]
    pub fn pk_client_set_locale(client: *mut PkClient, locale: *const c_char);
    #[cfg(any(feature = "v0_8_1", feature = "dox"))]
    pub fn pk_client_update_packages(
        client: *mut PkClient,
        transaction_flags: PkBitfield,
        package_ids: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_8_1", feature = "dox"))]
    pub fn pk_client_update_packages_async(
        client: *mut PkClient,
        transaction_flags: PkBitfield,
        package_ids: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v1_0_10", feature = "dox"))]
    pub fn pk_client_upgrade_system(
        client: *mut PkClient,
        transaction_flags: PkBitfield,
        distro_id: *const c_char,
        upgrade_kind: PkUpgradeKindEnum,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v1_0_10", feature = "dox"))]
    pub fn pk_client_upgrade_system_async(
        client: *mut PkClient,
        transaction_flags: PkBitfield,
        distro_id: *const c_char,
        upgrade_kind: PkUpgradeKindEnum,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_client_what_provides(
        client: *mut PkClient,
        filters: PkBitfield,
        values: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_client_what_provides_async(
        client: *mut PkClient,
        filters: PkBitfield,
        values: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );

    //=========================================================================
    // PkClientHelper
    //=========================================================================
    pub fn pk_client_helper_get_type() -> GType;
    #[cfg(any(feature = "v0_6_10", feature = "dox"))]
    pub fn pk_client_helper_new() -> *mut PkClientHelper;
    #[cfg(any(feature = "v1_1_13", feature = "dox"))]
    pub fn pk_client_helper_is_active(client_helper: *mut PkClientHelper) -> gboolean;
    #[cfg(any(feature = "v0_6_10", feature = "dox"))]
    pub fn pk_client_helper_start(
        client_helper: *mut PkClientHelper,
        socket_filename: *const c_char,
        argv: *mut *mut c_char,
        envp: *mut *mut c_char,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    #[cfg(any(feature = "v1_1_13", feature = "dox"))]
    pub fn pk_client_helper_start_with_socket(
        client_helper: *mut PkClientHelper,
        socket: *mut gio::GSocket,
        argv: *mut *mut c_char,
        envp: *mut *mut c_char,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    #[cfg(any(feature = "v0_6_10", feature = "dox"))]
    pub fn pk_client_helper_stop(
        client_helper: *mut PkClientHelper,
        error: *mut *mut glib::GError,
    ) -> gboolean;

    //=========================================================================
    // PkControl
    //=========================================================================
    pub fn pk_control_get_type() -> GType;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_control_new() -> *mut PkControl;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_control_can_authorize_async(
        control: *mut PkControl,
        action_id: *const c_char,
        cancellable: *mut gio::GCancellable,
        callback: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_control_can_authorize_finish(
        control: *mut PkControl,
        res: *mut gio::GAsyncResult,
        error: *mut *mut glib::GError,
    ) -> PkAuthorizeEnum;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_control_get_daemon_state_async(
        control: *mut PkControl,
        cancellable: *mut gio::GCancellable,
        callback: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_control_get_daemon_state_finish(
        control: *mut PkControl,
        res: *mut gio::GAsyncResult,
        error: *mut *mut glib::GError,
    ) -> *mut c_char;
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_control_get_properties(
        control: *mut PkControl,
        cancellable: *mut gio::GCancellable,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_control_get_properties_async(
        control: *mut PkControl,
        cancellable: *mut gio::GCancellable,
        callback: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_control_get_properties_finish(
        control: *mut PkControl,
        res: *mut gio::GAsyncResult,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_control_get_tid_async(
        control: *mut PkControl,
        cancellable: *mut gio::GCancellable,
        callback: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_control_get_tid_finish(
        control: *mut PkControl,
        res: *mut gio::GAsyncResult,
        error: *mut *mut glib::GError,
    ) -> *mut c_char;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_control_get_time_since_action_async(
        control: *mut PkControl,
        role: PkRoleEnum,
        cancellable: *mut gio::GCancellable,
        callback: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_control_get_time_since_action_finish(
        control: *mut PkControl,
        res: *mut gio::GAsyncResult,
        error: *mut *mut glib::GError,
    ) -> c_uint;
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_control_get_transaction_list(
        control: *mut PkControl,
        cancellable: *mut gio::GCancellable,
        error: *mut *mut glib::GError,
    ) -> *mut *mut c_char;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_control_get_transaction_list_async(
        control: *mut PkControl,
        cancellable: *mut gio::GCancellable,
        callback: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_control_get_transaction_list_finish(
        control: *mut PkControl,
        res: *mut gio::GAsyncResult,
        error: *mut *mut glib::GError,
    ) -> *mut *mut c_char;
    #[cfg(any(feature = "v0_6_3", feature = "dox"))]
    pub fn pk_control_set_proxy(
        control: *mut PkControl,
        proxy_http: *const c_char,
        proxy_ftp: *const c_char,
        cancellable: *mut gio::GCancellable,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    #[cfg(any(feature = "v0_6_13", feature = "dox"))]
    pub fn pk_control_set_proxy2(
        control: *mut PkControl,
        proxy_http: *const c_char,
        proxy_https: *const c_char,
        proxy_ftp: *const c_char,
        proxy_socks: *const c_char,
        no_proxy: *const c_char,
        pac: *const c_char,
        cancellable: *mut gio::GCancellable,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    #[cfg(any(feature = "v0_6_13", feature = "dox"))]
    pub fn pk_control_set_proxy2_async(
        control: *mut PkControl,
        proxy_http: *const c_char,
        proxy_https: *const c_char,
        proxy_ftp: *const c_char,
        proxy_socks: *const c_char,
        no_proxy: *const c_char,
        pac: *const c_char,
        cancellable: *mut gio::GCancellable,
        callback: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_control_set_proxy_async(
        control: *mut PkControl,
        proxy_http: *const c_char,
        proxy_ftp: *const c_char,
        cancellable: *mut gio::GCancellable,
        callback: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_control_set_proxy_finish(
        control: *mut PkControl,
        res: *mut gio::GAsyncResult,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    #[cfg(any(feature = "v0_6_2", feature = "dox"))]
    pub fn pk_control_suggest_daemon_quit(
        control: *mut PkControl,
        cancellable: *mut gio::GCancellable,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    #[cfg(any(feature = "v0_6_2", feature = "dox"))]
    pub fn pk_control_suggest_daemon_quit_async(
        control: *mut PkControl,
        cancellable: *mut gio::GCancellable,
        callback: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_6_2", feature = "dox"))]
    pub fn pk_control_suggest_daemon_quit_finish(
        control: *mut PkControl,
        res: *mut gio::GAsyncResult,
        error: *mut *mut glib::GError,
    ) -> gboolean;

    //=========================================================================
    // PkDesktop
    //=========================================================================
    pub fn pk_desktop_get_type() -> GType;
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_desktop_new() -> *mut PkDesktop;
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_desktop_get_files_for_package(
        desktop: *mut PkDesktop,
        package: *const c_char,
        error: *mut *mut glib::GError,
    ) -> *mut glib::GPtrArray;
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_desktop_get_package_for_file(
        desktop: *mut PkDesktop,
        filename: *const c_char,
        error: *mut *mut glib::GError,
    ) -> *mut c_char;
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_desktop_get_shown_for_package(
        desktop: *mut PkDesktop,
        package: *const c_char,
        error: *mut *mut glib::GError,
    ) -> *mut glib::GPtrArray;
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_desktop_open_database(
        desktop: *mut PkDesktop,
        error: *mut *mut glib::GError,
    ) -> gboolean;

    //=========================================================================
    // PkDetails
    //=========================================================================
    pub fn pk_details_get_type() -> GType;
    #[cfg(any(feature = "v0_5_4", feature = "dox"))]
    pub fn pk_details_new() -> *mut PkDetails;
    #[cfg(any(feature = "v0_8_12", feature = "dox"))]
    pub fn pk_details_get_description(details: *mut PkDetails) -> *const c_char;
    #[cfg(any(feature = "v0_8_12", feature = "dox"))]
    pub fn pk_details_get_group(details: *mut PkDetails) -> PkGroupEnum;
    #[cfg(any(feature = "v0_8_12", feature = "dox"))]
    pub fn pk_details_get_license(details: *mut PkDetails) -> *const c_char;
    #[cfg(any(feature = "v0_8_12", feature = "dox"))]
    pub fn pk_details_get_package_id(details: *mut PkDetails) -> *const c_char;
    #[cfg(any(feature = "v0_8_12", feature = "dox"))]
    pub fn pk_details_get_size(details: *mut PkDetails) -> u64;
    #[cfg(any(feature = "v0_9_1", feature = "dox"))]
    pub fn pk_details_get_summary(details: *mut PkDetails) -> *const c_char;
    #[cfg(any(feature = "v0_8_12", feature = "dox"))]
    pub fn pk_details_get_url(details: *mut PkDetails) -> *const c_char;

    //=========================================================================
    // PkDistroUpgrade
    //=========================================================================
    pub fn pk_distro_upgrade_get_type() -> GType;
    #[cfg(any(feature = "v0_5_4", feature = "dox"))]
    pub fn pk_distro_upgrade_new() -> *mut PkDistroUpgrade;
    #[cfg(any(feature = "v0_6_11", feature = "dox"))]
    pub fn pk_distro_upgrade_get_id(distro_upgrade: *mut PkDistroUpgrade) -> *const c_char;
    #[cfg(any(feature = "v0_6_11", feature = "dox"))]
    pub fn pk_distro_upgrade_get_state(distro_upgrade: *mut PkDistroUpgrade)
        -> PkDistroUpgradeEnum;
    #[cfg(any(feature = "v0_6_11", feature = "dox"))]
    pub fn pk_distro_upgrade_get_summary(distro_upgrade: *mut PkDistroUpgrade) -> *const c_char;

    //=========================================================================
    // PkError
    //=========================================================================
    pub fn pk_error_get_type() -> GType;
    #[cfg(any(feature = "v0_5_5", feature = "dox"))]
    pub fn pk_error_new() -> *mut PkError;
    #[cfg(any(feature = "v0_5_5", feature = "dox"))]
    pub fn pk_error_get_code(error_code: *mut PkError) -> PkErrorEnum;
    #[cfg(any(feature = "v0_5_5", feature = "dox"))]
    pub fn pk_error_get_details(error_code: *mut PkError) -> *const c_char;

    //=========================================================================
    // PkEulaRequired
    //=========================================================================
    pub fn pk_eula_required_get_type() -> GType;
    #[cfg(any(feature = "v0_5_4", feature = "dox"))]
    pub fn pk_eula_required_new() -> *mut PkEulaRequired;
    #[cfg(any(feature = "v1_1_8", feature = "dox"))]
    pub fn pk_eula_required_get_eula_id(eula_required: *mut PkEulaRequired) -> *const c_char;
    #[cfg(any(feature = "v1_1_8", feature = "dox"))]
    pub fn pk_eula_required_get_license_agreement(
        eula_required: *mut PkEulaRequired,
    ) -> *const c_char;
    #[cfg(any(feature = "v1_1_8", feature = "dox"))]
    pub fn pk_eula_required_get_package_id(eula_required: *mut PkEulaRequired) -> *const c_char;
    #[cfg(any(feature = "v1_1_8", feature = "dox"))]
    pub fn pk_eula_required_get_vendor_name(eula_required: *mut PkEulaRequired) -> *const c_char;

    //=========================================================================
    // PkFiles
    //=========================================================================
    pub fn pk_files_get_type() -> GType;
    #[cfg(any(feature = "v0_5_4", feature = "dox"))]
    pub fn pk_files_new() -> *mut PkFiles;
    #[cfg(any(feature = "v0_9_1", feature = "dox"))]
    pub fn pk_files_get_files(files: *mut PkFiles) -> *mut *mut c_char;
    #[cfg(any(feature = "v0_9_1", feature = "dox"))]
    pub fn pk_files_get_package_id(files: *mut PkFiles) -> *const c_char;

    //=========================================================================
    // PkItemProgress
    //=========================================================================
    pub fn pk_item_progress_get_type() -> GType;
    #[cfg(any(feature = "v0_8_1", feature = "dox"))]
    pub fn pk_item_progress_new() -> *mut PkItemProgress;
    pub fn pk_item_progress_get_package_id(item_progress: *mut PkItemProgress) -> *const c_char;
    pub fn pk_item_progress_get_percentage(item_progress: *mut PkItemProgress) -> c_uint;
    pub fn pk_item_progress_get_status(item_progress: *mut PkItemProgress) -> PkStatusEnum;

    //=========================================================================
    // PkMediaChangeRequired
    //=========================================================================
    pub fn pk_media_change_required_get_type() -> GType;
    #[cfg(any(feature = "v0_5_4", feature = "dox"))]
    pub fn pk_media_change_required_new() -> *mut PkMediaChangeRequired;

    //=========================================================================
    // PkPackage
    //=========================================================================
    pub fn pk_package_get_type() -> GType;
    #[cfg(any(feature = "v0_5_4", feature = "dox"))]
    pub fn pk_package_new() -> *mut PkPackage;
    #[cfg(any(feature = "v0_5", feature = "dox"))]
    pub fn pk_package_id_build(
        name: *const c_char,
        version: *const c_char,
        arch: *const c_char,
        data: *const c_char,
    ) -> *mut c_char;
    #[cfg(any(feature = "v0_5", feature = "dox"))]
    pub fn pk_package_id_check(package_id: *const c_char) -> gboolean;
    #[cfg(any(feature = "v0_5", feature = "dox"))]
    pub fn pk_package_id_equal_fuzzy_arch(
        package_id1: *const c_char,
        package_id2: *const c_char,
    ) -> gboolean;
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_package_id_split(package_id: *const c_char) -> *mut *mut c_char;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_package_id_to_printable(package_id: *const c_char) -> *mut c_char;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_package_ids_add_id(
        package_ids: *mut *mut c_char,
        package_id: *const c_char,
    ) -> *mut *mut c_char;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_package_ids_add_ids(
        package_ids: *mut *mut c_char,
        package_ids_new: *mut *mut c_char,
    ) -> *mut *mut c_char;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_package_ids_check(package_ids: *mut *mut c_char) -> gboolean;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_package_ids_from_id(package_id: *const c_char) -> *mut *mut c_char;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_package_ids_from_string(package_id: *const c_char) -> *mut *mut c_char;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_package_ids_present_id(
        package_ids: *mut *mut c_char,
        package_id: *const c_char,
    ) -> gboolean;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_package_ids_remove_id(
        package_ids: *mut *mut c_char,
        package_id: *const c_char,
    ) -> *mut *mut c_char;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_package_ids_to_string(package_ids: *mut *mut c_char) -> *mut c_char;
    #[cfg(any(feature = "v0_5_4", feature = "dox"))]
    pub fn pk_package_equal(package1: *mut PkPackage, package2: *mut PkPackage) -> gboolean;
    #[cfg(any(feature = "v0_5_4", feature = "dox"))]
    pub fn pk_package_equal_id(package1: *mut PkPackage, package2: *mut PkPackage) -> gboolean;
    #[cfg(any(feature = "v0_6_4", feature = "dox"))]
    pub fn pk_package_get_arch(package: *mut PkPackage) -> *const c_char;
    #[cfg(any(feature = "v0_6_4", feature = "dox"))]
    pub fn pk_package_get_data(package: *mut PkPackage) -> *const c_char;
    #[cfg(any(feature = "v0_5_4", feature = "dox"))]
    pub fn pk_package_get_id(package: *mut PkPackage) -> *const c_char;
    #[cfg(any(feature = "v0_5_4", feature = "dox"))]
    pub fn pk_package_get_info(package: *mut PkPackage) -> PkInfoEnum;
    #[cfg(any(feature = "v0_6_4", feature = "dox"))]
    pub fn pk_package_get_name(package: *mut PkPackage) -> *const c_char;
    #[cfg(any(feature = "v0_5_4", feature = "dox"))]
    pub fn pk_package_get_summary(package: *mut PkPackage) -> *const c_char;
    #[cfg(any(feature = "v0_6_4", feature = "dox"))]
    pub fn pk_package_get_version(package: *mut PkPackage) -> *const c_char;
    #[cfg(any(feature = "v0_8_11", feature = "dox"))]
    pub fn pk_package_parse(
        package: *mut PkPackage,
        data: *const c_char,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    #[cfg(any(feature = "v0_5_4", feature = "dox"))]
    pub fn pk_package_print(package: *mut PkPackage);
    #[cfg(any(feature = "v0_5_4", feature = "dox"))]
    pub fn pk_package_set_id(
        package: *mut PkPackage,
        package_id: *const c_char,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    #[cfg(any(feature = "v0_8_14", feature = "dox"))]
    pub fn pk_package_set_info(package: *mut PkPackage, info: PkInfoEnum);
    #[cfg(any(feature = "v0_8_14", feature = "dox"))]
    pub fn pk_package_set_summary(package: *mut PkPackage, summary: *const c_char);

    //=========================================================================
    // PkPackageSack
    //=========================================================================
    pub fn pk_package_sack_get_type() -> GType;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_package_sack_new() -> *mut PkPackageSack;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_package_sack_add_package(
        sack: *mut PkPackageSack,
        package: *mut PkPackage,
    ) -> gboolean;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_package_sack_add_package_by_id(
        sack: *mut PkPackageSack,
        package_id: *const c_char,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    pub fn pk_package_sack_add_packages_from_file(
        sack: *mut PkPackageSack,
        file: *mut gio::GFile,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_package_sack_clear(sack: *mut PkPackageSack);
    #[cfg(any(feature = "v0_6_3", feature = "dox"))]
    pub fn pk_package_sack_filter(
        sack: *mut PkPackageSack,
        filter_cb: PkPackageSackFilterFunc,
        user_data: gpointer,
    ) -> *mut PkPackageSack;
    #[cfg(any(feature = "v0_6_2", feature = "dox"))]
    pub fn pk_package_sack_filter_by_info(
        sack: *mut PkPackageSack,
        info: PkInfoEnum,
    ) -> *mut PkPackageSack;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_package_sack_find_by_id(
        sack: *mut PkPackageSack,
        package_id: *const c_char,
    ) -> *mut PkPackage;
    #[cfg(any(feature = "v0_8_16", feature = "dox"))]
    pub fn pk_package_sack_find_by_id_name_arch(
        sack: *mut PkPackageSack,
        package_id: *const c_char,
    ) -> *mut PkPackage;
    #[cfg(any(feature = "v0_6_1", feature = "dox"))]
    pub fn pk_package_sack_get_array(sack: *mut PkPackageSack) -> *mut glib::GPtrArray;
    #[cfg(any(feature = "v0_6", feature = "dox"))]
    pub fn pk_package_sack_get_details(
        package_sack: *mut PkPackageSack,
        cancellable: *mut gio::GCancellable,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    pub fn pk_package_sack_get_details_async(
        sack: *mut PkPackageSack,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_package_sack_get_ids(sack: *mut PkPackageSack) -> *mut *mut c_char;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_package_sack_get_size(sack: *mut PkPackageSack) -> c_uint;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_package_sack_get_total_bytes(sack: *mut PkPackageSack) -> u64;
    #[cfg(any(feature = "v0_6", feature = "dox"))]
    pub fn pk_package_sack_get_update_detail(
        package_sack: *mut PkPackageSack,
        cancellable: *mut gio::GCancellable,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_package_sack_get_update_detail_async(
        sack: *mut PkPackageSack,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_package_sack_merge_generic_finish(
        sack: *mut PkPackageSack,
        res: *mut gio::GAsyncResult,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    #[cfg(any(feature = "v0_6_3", feature = "dox"))]
    pub fn pk_package_sack_remove_by_filter(
        sack: *mut PkPackageSack,
        filter_cb: PkPackageSackFilterFunc,
        user_data: gpointer,
    ) -> gboolean;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_package_sack_remove_package(
        sack: *mut PkPackageSack,
        package: *mut PkPackage,
    ) -> gboolean;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_package_sack_remove_package_by_id(
        sack: *mut PkPackageSack,
        package_id: *const c_char,
    ) -> gboolean;
    #[cfg(any(feature = "v0_6", feature = "dox"))]
    pub fn pk_package_sack_resolve(
        package_sack: *mut PkPackageSack,
        cancellable: *mut gio::GCancellable,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_package_sack_resolve_async(
        sack: *mut PkPackageSack,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_6_1", feature = "dox"))]
    pub fn pk_package_sack_sort(sack: *mut PkPackageSack, type_: PkPackageSackSortType);
    #[cfg(any(feature = "v0_8_6", feature = "dox"))]
    pub fn pk_package_sack_to_file(
        sack: *mut PkPackageSack,
        file: *mut gio::GFile,
        error: *mut *mut glib::GError,
    ) -> gboolean;

    //=========================================================================
    // PkProgress
    //=========================================================================
    pub fn pk_progress_get_type() -> GType;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_progress_new() -> *mut PkProgress;
    #[cfg(any(feature = "v1_0_12", feature = "dox"))]
    pub fn pk_progress_get_allow_cancel(progress: *mut PkProgress) -> gboolean;
    #[cfg(any(feature = "v1_0_12", feature = "dox"))]
    pub fn pk_progress_get_caller_active(progress: *mut PkProgress) -> gboolean;
    #[cfg(any(feature = "v1_0_12", feature = "dox"))]
    pub fn pk_progress_get_download_size_remaining(progress: *mut PkProgress) -> u64;
    #[cfg(any(feature = "v1_0_12", feature = "dox"))]
    pub fn pk_progress_get_elapsed_time(progress: *mut PkProgress) -> c_uint;
    #[cfg(any(feature = "v1_0_12", feature = "dox"))]
    pub fn pk_progress_get_item_progress(progress: *mut PkProgress) -> *mut PkItemProgress;
    #[cfg(any(feature = "v1_0_12", feature = "dox"))]
    pub fn pk_progress_get_package(progress: *mut PkProgress) -> *mut PkPackage;
    #[cfg(any(feature = "v1_0_12", feature = "dox"))]
    pub fn pk_progress_get_package_id(progress: *mut PkProgress) -> *const c_char;
    #[cfg(any(feature = "v1_0_12", feature = "dox"))]
    pub fn pk_progress_get_percentage(progress: *mut PkProgress) -> c_int;
    #[cfg(any(feature = "v1_0_12", feature = "dox"))]
    pub fn pk_progress_get_remaining_time(progress: *mut PkProgress) -> c_uint;
    #[cfg(any(feature = "v1_0_12", feature = "dox"))]
    pub fn pk_progress_get_role(progress: *mut PkProgress) -> PkRoleEnum;
    #[cfg(any(feature = "v1_0_12", feature = "dox"))]
    pub fn pk_progress_get_speed(progress: *mut PkProgress) -> c_uint;
    #[cfg(any(feature = "v1_0_12", feature = "dox"))]
    pub fn pk_progress_get_status(progress: *mut PkProgress) -> PkStatusEnum;
    #[cfg(any(feature = "v1_0_12", feature = "dox"))]
    pub fn pk_progress_get_transaction_flags(progress: *mut PkProgress) -> u64;
    #[cfg(any(feature = "v1_0_12", feature = "dox"))]
    pub fn pk_progress_get_transaction_id(progress: *mut PkProgress) -> *const c_char;
    #[cfg(any(feature = "v1_0_12", feature = "dox"))]
    pub fn pk_progress_get_uid(progress: *mut PkProgress) -> c_uint;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_progress_set_allow_cancel(
        progress: *mut PkProgress,
        allow_cancel: gboolean,
    ) -> gboolean;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_progress_set_caller_active(
        progress: *mut PkProgress,
        caller_active: gboolean,
    ) -> gboolean;
    #[cfg(any(feature = "v0_8", feature = "dox"))]
    pub fn pk_progress_set_download_size_remaining(
        progress: *mut PkProgress,
        download_size_remaining: u64,
    ) -> gboolean;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_progress_set_elapsed_time(
        progress: *mut PkProgress,
        elapsed_time: c_uint,
    ) -> gboolean;
    #[cfg(any(feature = "v0_8_1", feature = "dox"))]
    pub fn pk_progress_set_item_progress(
        progress: *mut PkProgress,
        item_progress: *mut PkItemProgress,
    ) -> gboolean;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_progress_set_package(progress: *mut PkProgress, package: *mut PkPackage) -> gboolean;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_progress_set_package_id(
        progress: *mut PkProgress,
        package_id: *const c_char,
    ) -> gboolean;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_progress_set_percentage(progress: *mut PkProgress, percentage: c_int) -> gboolean;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_progress_set_remaining_time(
        progress: *mut PkProgress,
        remaining_time: c_uint,
    ) -> gboolean;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_progress_set_role(progress: *mut PkProgress, role: PkRoleEnum) -> gboolean;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_progress_set_speed(progress: *mut PkProgress, speed: c_uint) -> gboolean;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_progress_set_status(progress: *mut PkProgress, status: PkStatusEnum) -> gboolean;
    #[cfg(any(feature = "v0_8_8", feature = "dox"))]
    pub fn pk_progress_set_transaction_flags(
        progress: *mut PkProgress,
        transaction_flags: u64,
    ) -> gboolean;
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_progress_set_transaction_id(
        progress: *mut PkProgress,
        transaction_id: *const c_char,
    ) -> gboolean;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_progress_set_uid(progress: *mut PkProgress, uid: c_uint) -> gboolean;

    //=========================================================================
    // PkRepoDetail
    //=========================================================================
    pub fn pk_repo_detail_get_type() -> GType;
    #[cfg(any(feature = "v0_5_4", feature = "dox"))]
    pub fn pk_repo_detail_new() -> *mut PkRepoDetail;
    #[cfg(any(feature = "v0_9_1", feature = "dox"))]
    pub fn pk_repo_detail_get_description(repo_detail: *mut PkRepoDetail) -> *const c_char;
    #[cfg(any(feature = "v0_9_1", feature = "dox"))]
    pub fn pk_repo_detail_get_enabled(repo_detail: *mut PkRepoDetail) -> gboolean;
    #[cfg(any(feature = "v0_9_1", feature = "dox"))]
    pub fn pk_repo_detail_get_id(repo_detail: *mut PkRepoDetail) -> *const c_char;

    //=========================================================================
    // PkRepoSignatureRequired
    //=========================================================================
    pub fn pk_repo_signature_required_get_type() -> GType;
    #[cfg(any(feature = "v0_5_4", feature = "dox"))]
    pub fn pk_repo_signature_required_new() -> *mut PkRepoSignatureRequired;

    //=========================================================================
    // PkRequireRestart
    //=========================================================================
    pub fn pk_require_restart_get_type() -> GType;
    #[cfg(any(feature = "v0_5_4", feature = "dox"))]
    pub fn pk_require_restart_new() -> *mut PkRequireRestart;

    //=========================================================================
    // PkResults
    //=========================================================================
    pub fn pk_results_get_type() -> GType;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_results_new() -> *mut PkResults;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_results_add_category(results: *mut PkResults, item: *mut PkCategory) -> gboolean;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_results_add_details(results: *mut PkResults, item: *mut PkDetails) -> gboolean;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_results_add_distro_upgrade(
        results: *mut PkResults,
        item: *mut PkDistroUpgrade,
    ) -> gboolean;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_results_add_eula_required(
        results: *mut PkResults,
        item: *mut PkEulaRequired,
    ) -> gboolean;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_results_add_files(results: *mut PkResults, item: *mut PkFiles) -> gboolean;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_results_add_media_change_required(
        results: *mut PkResults,
        item: *mut PkMediaChangeRequired,
    ) -> gboolean;
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_results_add_package(results: *mut PkResults, item: *mut PkPackage) -> gboolean;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_results_add_repo_detail(results: *mut PkResults, item: *mut PkRepoDetail)
        -> gboolean;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_results_add_repo_signature_required(
        results: *mut PkResults,
        item: *mut PkRepoSignatureRequired,
    ) -> gboolean;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_results_add_require_restart(
        results: *mut PkResults,
        item: *mut PkRequireRestart,
    ) -> gboolean;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_results_add_transaction(
        results: *mut PkResults,
        item: *mut PkTransactionPast,
    ) -> gboolean;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_results_add_update_detail(
        results: *mut PkResults,
        item: *mut PkUpdateDetail,
    ) -> gboolean;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_results_get_category_array(results: *mut PkResults) -> *mut glib::GPtrArray;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_results_get_details_array(results: *mut PkResults) -> *mut glib::GPtrArray;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_results_get_distro_upgrade_array(results: *mut PkResults) -> *mut glib::GPtrArray;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_results_get_error_code(results: *mut PkResults) -> *mut PkError;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_results_get_eula_required_array(results: *mut PkResults) -> *mut glib::GPtrArray;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_results_get_exit_code(results: *mut PkResults) -> PkExitEnum;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_results_get_files_array(results: *mut PkResults) -> *mut glib::GPtrArray;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_results_get_media_change_required_array(
        results: *mut PkResults,
    ) -> *mut glib::GPtrArray;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_results_get_package_array(results: *mut PkResults) -> *mut glib::GPtrArray;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_results_get_package_sack(results: *mut PkResults) -> *mut PkPackageSack;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_results_get_repo_detail_array(results: *mut PkResults) -> *mut glib::GPtrArray;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_results_get_repo_signature_required_array(
        results: *mut PkResults,
    ) -> *mut glib::GPtrArray;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_results_get_require_restart_array(results: *mut PkResults) -> *mut glib::GPtrArray;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_results_get_require_restart_worst(results: *mut PkResults) -> PkRestartEnum;
    #[cfg(any(feature = "v0_7_5", feature = "dox"))]
    pub fn pk_results_get_role(results: *mut PkResults) -> PkRoleEnum;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_results_get_transaction_array(results: *mut PkResults) -> *mut glib::GPtrArray;
    #[cfg(any(feature = "v0_8_1", feature = "dox"))]
    pub fn pk_results_get_transaction_flags(results: *mut PkResults) -> PkBitfield;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_results_get_update_detail_array(results: *mut PkResults) -> *mut glib::GPtrArray;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_results_set_error_code(results: *mut PkResults, item: *mut PkError) -> gboolean;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_results_set_exit_code(results: *mut PkResults, exit_enum: PkExitEnum) -> gboolean;
    #[cfg(any(feature = "v1_1_8", feature = "dox"))]
    pub fn pk_results_set_role(results: *mut PkResults, role: PkRoleEnum) -> gboolean;

    //=========================================================================
    // PkSource
    //=========================================================================
    pub fn pk_source_get_type() -> GType;
    #[cfg(any(feature = "v0_6", feature = "dox"))]
    pub fn pk_source_new() -> *mut PkSource;

    //=========================================================================
    // PkTask
    //=========================================================================
    pub fn pk_task_get_type() -> GType;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_task_new() -> *mut PkTask;
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_depends_on_async(
        task: *mut PkTask,
        filters: PkBitfield,
        package_ids: *mut *mut c_char,
        recursive: gboolean,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_depends_on_sync(
        task: *mut PkTask,
        filters: PkBitfield,
        package_ids: *mut *mut c_char,
        recursive: gboolean,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_download_packages_async(
        task: *mut PkTask,
        package_ids: *mut *mut c_char,
        directory: *const c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_download_packages_sync(
        task: *mut PkTask,
        package_ids: *mut *mut c_char,
        directory: *const c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_task_generic_finish(
        task: *mut PkTask,
        res: *mut gio::GAsyncResult,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v1_0_2", feature = "dox"))]
    pub fn pk_task_get_allow_downgrade(task: *mut PkTask) -> gboolean;
    #[cfg(any(feature = "v1_0_2", feature = "dox"))]
    pub fn pk_task_get_allow_reinstall(task: *mut PkTask) -> gboolean;
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_get_categories_async(
        task: *mut PkTask,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_get_categories_sync(
        task: *mut PkTask,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_get_details_async(
        task: *mut PkTask,
        package_ids: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_get_details_sync(
        task: *mut PkTask,
        package_ids: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_get_files_async(
        task: *mut PkTask,
        package_ids: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_get_files_sync(
        task: *mut PkTask,
        package_ids: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_8_1", feature = "dox"))]
    pub fn pk_task_get_only_download(task: *mut PkTask) -> gboolean;
    #[cfg(any(feature = "v0_9_5", feature = "dox"))]
    pub fn pk_task_get_only_trusted(task: *mut PkTask) -> gboolean;
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_get_packages_async(
        task: *mut PkTask,
        filters: PkBitfield,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_get_packages_sync(
        task: *mut PkTask,
        filters: PkBitfield,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_get_repo_list_async(
        task: *mut PkTask,
        filters: PkBitfield,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_get_repo_list_sync(
        task: *mut PkTask,
        filters: PkBitfield,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_6_10", feature = "dox"))]
    pub fn pk_task_get_simulate(task: *mut PkTask) -> gboolean;
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_get_update_detail_async(
        task: *mut PkTask,
        package_ids: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_get_update_detail_sync(
        task: *mut PkTask,
        package_ids: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_get_updates_async(
        task: *mut PkTask,
        filters: PkBitfield,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_get_updates_sync(
        task: *mut PkTask,
        filters: PkBitfield,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_task_install_files_async(
        task: *mut PkTask,
        files: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_task_install_files_sync(
        task: *mut PkTask,
        files: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_task_install_packages_async(
        task: *mut PkTask,
        package_ids: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_task_install_packages_sync(
        task: *mut PkTask,
        package_ids: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_refresh_cache_async(
        task: *mut PkTask,
        force: gboolean,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_refresh_cache_sync(
        task: *mut PkTask,
        force: gboolean,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_task_remove_packages_async(
        task: *mut PkTask,
        package_ids: *mut *mut c_char,
        allow_deps: gboolean,
        autoremove: gboolean,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_task_remove_packages_sync(
        task: *mut PkTask,
        package_ids: *mut *mut c_char,
        allow_deps: gboolean,
        autoremove: gboolean,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_7_2", feature = "dox"))]
    pub fn pk_task_repair_system_async(
        task: *mut PkTask,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_7_2", feature = "dox"))]
    pub fn pk_task_repair_system_sync(
        task: *mut PkTask,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_repo_enable_async(
        task: *mut PkTask,
        repo_id: *const c_char,
        enabled: gboolean,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_repo_enable_sync(
        task: *mut PkTask,
        repo_id: *const c_char,
        enabled: gboolean,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_required_by_async(
        task: *mut PkTask,
        filters: PkBitfield,
        package_ids: *mut *mut c_char,
        recursive: gboolean,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_required_by_sync(
        task: *mut PkTask,
        filters: PkBitfield,
        package_ids: *mut *mut c_char,
        recursive: gboolean,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_resolve_async(
        task: *mut PkTask,
        filters: PkBitfield,
        packages: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_resolve_sync(
        task: *mut PkTask,
        filters: PkBitfield,
        packages: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_search_details_async(
        task: *mut PkTask,
        filters: PkBitfield,
        values: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_search_details_sync(
        task: *mut PkTask,
        filters: PkBitfield,
        values: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_search_files_async(
        task: *mut PkTask,
        filters: PkBitfield,
        values: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_search_files_sync(
        task: *mut PkTask,
        filters: PkBitfield,
        values: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_search_groups_async(
        task: *mut PkTask,
        filters: PkBitfield,
        values: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_search_groups_sync(
        task: *mut PkTask,
        filters: PkBitfield,
        values: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_search_names_async(
        task: *mut PkTask,
        filters: PkBitfield,
        values: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_search_names_sync(
        task: *mut PkTask,
        filters: PkBitfield,
        values: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v1_0_2", feature = "dox"))]
    pub fn pk_task_set_allow_downgrade(task: *mut PkTask, allow_downgrade: gboolean);
    #[cfg(any(feature = "v1_0_2", feature = "dox"))]
    pub fn pk_task_set_allow_reinstall(task: *mut PkTask, allow_reinstall: gboolean);
    #[cfg(any(feature = "v0_8_1", feature = "dox"))]
    pub fn pk_task_set_only_download(task: *mut PkTask, only_download: gboolean);
    #[cfg(any(feature = "v0_9_5", feature = "dox"))]
    pub fn pk_task_set_only_trusted(task: *mut PkTask, only_trusted: gboolean);
    #[cfg(any(feature = "v0_6_10", feature = "dox"))]
    pub fn pk_task_set_simulate(task: *mut PkTask, simulate: gboolean);
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_task_update_packages_async(
        task: *mut PkTask,
        package_ids: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_task_update_packages_sync(
        task: *mut PkTask,
        package_ids: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v1_0_12", feature = "dox"))]
    pub fn pk_task_upgrade_system_async(
        task: *mut PkTask,
        distro_id: *const c_char,
        upgrade_kind: PkUpgradeKindEnum,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v1_0_12", feature = "dox"))]
    pub fn pk_task_upgrade_system_sync(
        task: *mut PkTask,
        distro_id: *const c_char,
        upgrade_kind: PkUpgradeKindEnum,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_task_user_accepted(task: *mut PkTask, request: c_uint) -> gboolean;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_task_user_declined(task: *mut PkTask, request: c_uint) -> gboolean;
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_what_provides_async(
        task: *mut PkTask,
        filters: PkBitfield,
        values: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        callback_ready: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v0_6_5", feature = "dox"))]
    pub fn pk_task_what_provides_sync(
        task: *mut PkTask,
        filters: PkBitfield,
        values: *mut *mut c_char,
        cancellable: *mut gio::GCancellable,
        progress_callback: PkProgressCallback,
        progress_user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> *mut PkResults;

    //=========================================================================
    // PkTransactionList
    //=========================================================================
    pub fn pk_transaction_list_get_type() -> GType;
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_transaction_list_new() -> *mut PkTransactionList;
    #[cfg(any(feature = "v0_5_3", feature = "dox"))]
    pub fn pk_transaction_list_get_ids(tlist: *mut PkTransactionList) -> *mut *mut c_char;

    //=========================================================================
    // PkTransactionPast
    //=========================================================================
    pub fn pk_transaction_past_get_type() -> GType;
    #[cfg(any(feature = "v0_5_4", feature = "dox"))]
    pub fn pk_transaction_past_new() -> *mut PkTransactionPast;
    #[cfg(any(feature = "v0_8_11", feature = "dox"))]
    pub fn pk_transaction_past_get_cmdline(past: *mut PkTransactionPast) -> *const c_char;
    #[cfg(any(feature = "v0_8_11", feature = "dox"))]
    pub fn pk_transaction_past_get_data(past: *mut PkTransactionPast) -> *const c_char;
    #[cfg(any(feature = "v0_8_11", feature = "dox"))]
    pub fn pk_transaction_past_get_datetime(past: *mut PkTransactionPast) -> *mut glib::GDateTime;
    #[cfg(any(feature = "v0_8_11", feature = "dox"))]
    pub fn pk_transaction_past_get_duration(past: *mut PkTransactionPast) -> c_uint;
    #[cfg(any(feature = "v0_8_11", feature = "dox"))]
    pub fn pk_transaction_past_get_id(past: *mut PkTransactionPast) -> *const c_char;
    #[cfg(any(feature = "v0_8_11", feature = "dox"))]
    pub fn pk_transaction_past_get_role(past: *mut PkTransactionPast) -> PkRoleEnum;
    #[cfg(any(feature = "v0_8_11", feature = "dox"))]
    pub fn pk_transaction_past_get_succeeded(past: *mut PkTransactionPast) -> gboolean;
    #[cfg(any(feature = "v0_8_11", feature = "dox"))]
    pub fn pk_transaction_past_get_timespec(past: *mut PkTransactionPast) -> *const c_char;
    #[cfg(any(feature = "v0_8_11", feature = "dox"))]
    pub fn pk_transaction_past_get_timestamp(past: *mut PkTransactionPast) -> i64;
    #[cfg(any(feature = "v0_8_11", feature = "dox"))]
    pub fn pk_transaction_past_get_uid(past: *mut PkTransactionPast) -> c_uint;

    //=========================================================================
    // PkUpdateDetail
    //=========================================================================
    pub fn pk_update_detail_get_type() -> GType;
    #[cfg(any(feature = "v0_5_4", feature = "dox"))]
    pub fn pk_update_detail_new() -> *mut PkUpdateDetail;
    #[cfg(any(feature = "v0_8_8", feature = "dox"))]
    pub fn pk_update_detail_get_bugzilla_urls(
        update_detail: *mut PkUpdateDetail,
    ) -> *mut *mut c_char;
    #[cfg(any(feature = "v0_8_8", feature = "dox"))]
    pub fn pk_update_detail_get_changelog(update_detail: *mut PkUpdateDetail) -> *const c_char;
    #[cfg(any(feature = "v0_8_8", feature = "dox"))]
    pub fn pk_update_detail_get_cve_urls(update_detail: *mut PkUpdateDetail) -> *mut *mut c_char;
    #[cfg(any(feature = "v0_8_8", feature = "dox"))]
    pub fn pk_update_detail_get_issued(update_detail: *mut PkUpdateDetail) -> *const c_char;
    #[cfg(any(feature = "v0_8_8", feature = "dox"))]
    pub fn pk_update_detail_get_obsoletes(update_detail: *mut PkUpdateDetail) -> *mut *mut c_char;
    #[cfg(any(feature = "v0_8_8", feature = "dox"))]
    pub fn pk_update_detail_get_package_id(update_detail: *mut PkUpdateDetail) -> *const c_char;
    #[cfg(any(feature = "v0_8_8", feature = "dox"))]
    pub fn pk_update_detail_get_restart(update_detail: *mut PkUpdateDetail) -> PkRestartEnum;
    #[cfg(any(feature = "v0_8_8", feature = "dox"))]
    pub fn pk_update_detail_get_state(update_detail: *mut PkUpdateDetail) -> PkUpdateStateEnum;
    #[cfg(any(feature = "v0_8_8", feature = "dox"))]
    pub fn pk_update_detail_get_update_text(update_detail: *mut PkUpdateDetail) -> *const c_char;
    #[cfg(any(feature = "v0_8_8", feature = "dox"))]
    pub fn pk_update_detail_get_updated(update_detail: *mut PkUpdateDetail) -> *const c_char;
    #[cfg(any(feature = "v0_8_8", feature = "dox"))]
    pub fn pk_update_detail_get_updates(update_detail: *mut PkUpdateDetail) -> *mut *mut c_char;
    #[cfg(any(feature = "v0_8_8", feature = "dox"))]
    pub fn pk_update_detail_get_vendor_urls(update_detail: *mut PkUpdateDetail)
        -> *mut *mut c_char;

    //=========================================================================
    // Other functions
    //=========================================================================
    #[cfg(any(feature = "v0_5", feature = "dox"))]
    pub fn pk_authorize_type_enum_from_string(authorize_type: *const c_char) -> PkAuthorizeEnum;
    #[cfg(any(feature = "v0_5", feature = "dox"))]
    pub fn pk_authorize_type_enum_to_string(authorize_type: PkAuthorizeEnum) -> *const c_char;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_bitfield_contain_priority(values: PkBitfield, value: c_int, ...) -> c_int;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_bitfield_from_enums(value: c_int, ...) -> PkBitfield;
    pub fn pk_debug_add_log_domain(log_domain: *const c_char);
    pub fn pk_debug_get_option_group() -> *mut glib::GOptionGroup;
    pub fn pk_debug_is_verbose() -> gboolean;
    pub fn pk_debug_set_verbose(verbose: gboolean);
    pub fn pk_enum_find_string(table: *const PkEnumMatch, value: c_uint) -> *const c_char;
    pub fn pk_enum_find_value(table: *const PkEnumMatch, string: *const c_char) -> c_uint;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_filter_bitfield_from_string(filters: *const c_char) -> PkBitfield;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_filter_bitfield_to_string(filters: PkBitfield) -> *mut c_char;
    pub fn pk_get_distro_id() -> *mut c_char;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_group_bitfield_from_string(groups: *const c_char) -> PkBitfield;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_group_bitfield_to_string(groups: PkBitfield) -> *mut c_char;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_iso8601_from_date(date: *const glib::GDate) -> *mut c_char;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_iso8601_present() -> *mut c_char;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_iso8601_to_date(iso_date: *const c_char) -> *mut glib::GDate;
    #[cfg(any(feature = "v0_8_11", feature = "dox"))]
    pub fn pk_iso8601_to_datetime(iso_date: *const c_char) -> *mut glib::GDateTime;
    pub fn pk_offline_auth_cancel(error: *mut *mut glib::GError) -> gboolean;
    pub fn pk_offline_auth_clear_results(error: *mut *mut glib::GError) -> gboolean;
    pub fn pk_offline_auth_invalidate(error: *mut *mut glib::GError) -> gboolean;
    pub fn pk_offline_auth_set_action(
        action: PkOfflineAction,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    pub fn pk_offline_auth_set_prepared_ids(
        package_ids: *mut *mut c_char,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    pub fn pk_offline_auth_set_prepared_upgrade(
        name: *const c_char,
        release_ver: *const c_char,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    pub fn pk_offline_auth_set_results(
        results: *mut PkResults,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    pub fn pk_offline_auth_trigger(
        action: PkOfflineAction,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    pub fn pk_offline_auth_trigger_upgrade(
        action: PkOfflineAction,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    #[cfg(any(feature = "v0_9_6", feature = "dox"))]
    pub fn pk_offline_cancel(
        cancellable: *mut gio::GCancellable,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    #[cfg(any(feature = "v0_9_6", feature = "dox"))]
    pub fn pk_offline_clear_results(
        cancellable: *mut gio::GCancellable,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    #[cfg(any(feature = "v0_9_6", feature = "dox"))]
    pub fn pk_offline_get_action(error: *mut *mut glib::GError) -> PkOfflineAction;
    #[cfg(any(feature = "v0_9_6", feature = "dox"))]
    pub fn pk_offline_get_action_monitor(
        cancellable: *mut gio::GCancellable,
        error: *mut *mut glib::GError,
    ) -> *mut gio::GFileMonitor;
    #[cfg(any(feature = "v0_9_6", feature = "dox"))]
    pub fn pk_offline_get_prepared_ids(error: *mut *mut glib::GError) -> *mut *mut c_char;
    #[cfg(any(feature = "v0_9_6", feature = "dox"))]
    pub fn pk_offline_get_prepared_monitor(
        cancellable: *mut gio::GCancellable,
        error: *mut *mut glib::GError,
    ) -> *mut gio::GFileMonitor;
    #[cfg(any(feature = "v0_9_6", feature = "dox"))]
    pub fn pk_offline_get_prepared_sack(error: *mut *mut glib::GError) -> *mut PkPackageSack;
    pub fn pk_offline_get_prepared_upgrade(
        name: *mut *mut c_char,
        release_ver: *mut *mut c_char,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    #[cfg(any(feature = "v1_0_12", feature = "dox"))]
    pub fn pk_offline_get_prepared_upgrade_monitor(
        cancellable: *mut gio::GCancellable,
        error: *mut *mut glib::GError,
    ) -> *mut gio::GFileMonitor;
    #[cfg(any(feature = "v1_1_2", feature = "dox"))]
    pub fn pk_offline_get_prepared_upgrade_name(error: *mut *mut glib::GError) -> *mut c_char;
    #[cfg(any(feature = "v1_0_12", feature = "dox"))]
    pub fn pk_offline_get_prepared_upgrade_version(error: *mut *mut glib::GError) -> *mut c_char;
    #[cfg(any(feature = "v0_9_6", feature = "dox"))]
    pub fn pk_offline_get_results(error: *mut *mut glib::GError) -> *mut PkResults;
    #[cfg(any(feature = "v0_9_6", feature = "dox"))]
    pub fn pk_offline_get_results_mtime(error: *mut *mut glib::GError) -> u64;
    #[cfg(any(feature = "v0_9_6", feature = "dox"))]
    pub fn pk_offline_trigger(
        action: PkOfflineAction,
        cancellable: *mut gio::GCancellable,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    #[cfg(any(feature = "v1_0_12", feature = "dox"))]
    pub fn pk_offline_trigger_upgrade(
        action: PkOfflineAction,
        cancellable: *mut gio::GCancellable,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    pub fn pk_polkit_agent_close();
    pub fn pk_polkit_agent_open() -> c_int;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_ptr_array_to_strv(array: *mut glib::GPtrArray) -> *mut *mut c_char;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_role_bitfield_from_string(roles: *const c_char) -> PkBitfield;
    #[cfg(any(feature = "v0_5_2", feature = "dox"))]
    pub fn pk_role_bitfield_to_string(roles: PkBitfield) -> *mut c_char;
    #[cfg(any(feature = "v0_8_1", feature = "dox"))]
    pub fn pk_transaction_flag_bitfield_from_string(transaction_flags: *const c_char)
        -> PkBitfield;
    #[cfg(any(feature = "v0_8_1", feature = "dox"))]
    pub fn pk_transaction_flag_bitfield_to_string(transaction_flags: PkBitfield) -> *mut c_char;

}
